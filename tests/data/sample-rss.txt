<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Google Developers - Medium]]></title>
        <description><![CDATA[Engineering and technology articles for developers, written and curated by Googlers. The views expressed are those of the authors and don‚Äôt necessarily reflect those of Google. - Medium]]></description>
        <link>https://medium.com/google-developers?source=rss----2e5ce7f173a5---4</link>
        <image>
            <url>https://cdn-images-1.medium.com/proxy/1*MXL-j6S8fTEd8UFP_foEEw.png</url>
            <title>Google Developers - Medium</title>
            <link>https://medium.com/google-developers?source=rss----2e5ce7f173a5---4</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Fri, 04 Aug 2017 14:04:39 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/google-developers" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[The Developer Show ‚Äî TL;DR 077]]></title>
            <link>https://medium.com/google-developers/the-developer-show-tl-dr-077-105c996d8c6e?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/105c996d8c6e</guid>
            <category><![CDATA[dart]]></category>
            <category><![CDATA[google-cloud-platform]]></category>
            <category><![CDATA[machine-learning]]></category>
            <category><![CDATA[g-suite]]></category>
            <dc:creator><![CDATA[timothyjordan]]></dc:creator>
            <pubDate>Thu, 03 Aug 2017 18:45:12 GMT</pubDate>
            <atom:updated>2017-08-03T18:45:12.879Z</atom:updated>
            <content:encoded><![CDATA[<p>The Developer Show is where you can stay up to date on all the latest Google Developer news, straight from the experts.</p><p>Have a question? Use #AskDevShow to let us know!</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fvideoseries%3Flist%3DPLOU2XLYxmsII8REpkzsy1bJHj6G1WEVA1&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D1rF4LJfLftw&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F1rF4LJfLftw%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/f884cf1519a46af347350c89b7966dd6/href">https://medium.com/media/f884cf1519a46af347350c89b7966dd6/href</a></iframe><h4><a href="https://research.googleblog.com/2017/07/facets-open-source-visualization-tool.html?utm_campaign=devshow_series_introducingfacets_072817&amp;utm_source=gdev&amp;utm_medium=blog">Introducing Facets</a></h4><p>Getting the best results out of a machine learning model requires that you truly understand your data. However, ML datasets can contain hundreds of millions of data points, each consisting of hundreds, or even thousands, of features. Working with the PAIR initiative, we‚Äôve released Facets, an open source visualization tool to aid in understanding and analyzing ML datasets. <a href="https://research.googleblog.com/2017/07/facets-open-source-visualization-tool.html?utm_campaign=devshow_series_introducingfacets_072817&amp;utm_source=gdev&amp;utm_medium=blog">For more details and some very cool screenshots, head on over to the post</a>.</p><h4><a href="https://research.googleblog.com/2017/07/google-at-cvpr-2017.html?utm_campaign=devshow_series_cvpr_073117&amp;utm_source=gdev&amp;utm_medium=blog">Google at CVPR 2017</a></h4><p>The 2017 Conference on Computer Vision and Pattern Recognition happened in Hawaii this week. But don‚Äôt worry if you couldn‚Äôt make it, you can <a href="https://research.googleblog.com/2017/07/google-at-cvpr-2017.html?utm_campaign=devshow_series_cvpr_073117&amp;utm_source=gdev&amp;utm_medium=blog">learn more about the research we presented from the post</a>.</p><h4><a href="https://research.googleblog.com/2017/07/an-update-to-open-images-now-with.html?utm_campaign=devshow_series_boundingboxes_072817&amp;utm_source=gdev&amp;utm_medium=blog">An Update to Open Images‚Ää‚Äî‚ÄäNow with Bounding-Boxes</a></h4><p>Last year we introduced Open Images, a collaborative release of about 9 million images annotated with labels spanning over 6000 object categories, designed to be a useful dataset for machine learning research. We just introduced an update to Open Images, which contains the addition of about 2 million bounding-boxes to the existing dataset, along with several million additional image-level labels. <a href="https://research.googleblog.com/2017/07/an-update-to-open-images-now-with.html?utm_campaign=devshow_series_boundingboxes_072817&amp;utm_source=gdev&amp;utm_medium=blog">More details and a link to the GitHub are on the post</a>.</p><h4><a href="http://news.dartlang.org/2017/06/a-stronger-dart-for-everyone.html?utm_campaign=devshow_series_strongerdart_072817&amp;utm_source=gdev&amp;utm_medium=blog">A stronger Dart for everyone</a></h4><p>Given the benefits of strong mode, and the large number of users already using it, we have decided to make strong mode the standard type system for Dart. This will happen in three phases: strong mode is opt in, strong mode is the default, and strong mode is the only mode. <a href="http://news.dartlang.org/2017/06/a-stronger-dart-for-everyone.html?utm_campaign=devshow_series_strongerdart_072817&amp;utm_source=gdev&amp;utm_medium=blog">For details on how we are making sure that you have a smooth transition to the new type system, check out the post</a>.</p><h4><a href="https://gsuite-developers.googleblog.com/2017/07/new-security-protections-to-reduce-risk.html?utm_campaign=devshow_series_gsuitesecurity_072817&amp;utm_source=gdev&amp;utm_medium=blog">New security protections for G Suite apps</a></h4><p>We recently introduced bolder warnings to inform users about newly created web apps and Apps Scripts for GSuite that are pending verification. In the coming months, we will begin expanding the verification process and the new warnings to existing apps as well. <a href="https://gsuite-developers.googleblog.com/2017/07/new-security-protections-to-reduce-risk.html?utm_campaign=devshow_series_gsuitesecurity_072817&amp;utm_source=gdev&amp;utm_medium=blog">For screenshots and tips on getting ready, take a look at the post</a>.</p><h4><a href="https://cloudplatform.googleblog.com/2017/07/how-to-get-started-with-cloud-spanner-in-5-minutes.html?utm_campaign=devshow_series_cloudspanner_072817&amp;utm_source=gdev&amp;utm_medium=blog">Cloud Spanner in 5 minutes</a></h4><p>With Cloud Spanner, you have direct access to a horizontally-scaling, cloud-native infrastructure that provides global transactions. Think: apps that involve payments, inventory, ticketing, or even financial trading. Thanks to the Google Cloud Platform Free Trial that offers 300 dollars in credits for one year <a href="https://cloudplatform.googleblog.com/2017/07/how-to-get-started-with-cloud-spanner-in-5-minutes.html?utm_campaign=devshow_series_cloudspanner_072817&amp;utm_source=gdev&amp;utm_medium=blog">and this guide</a>, you can get your feet wet with Cloud Spanner in 5 minutes.</p><h4><a href="https://cloudplatform.googleblog.com/2017/07/introducing-Transfer-Appliance-Sneakernet-for-the-cloud-era.html?utm_campaign=devshow_series_transferappliance_072817&amp;utm_source=gdev&amp;utm_medium=blog">Introducing Transfer Appliance</a></h4><p>We recently introduced Transfer Appliance; with a capacity of up to one-petabyte compressed, it helps you migrate your data to Google Cloud Platform orders-of-magnitude faster than over a typical network. Simply fill this rackable high-capacity storage server from your data center and then ship it to us, and we‚Äôll upload your data to Google Cloud Storage. <a href="https://cloudplatform.googleblog.com/2017/07/introducing-Transfer-Appliance-Sneakernet-for-the-cloud-era.html?utm_campaign=devshow_series_transferappliance_072817&amp;utm_source=gdev&amp;utm_medium=blog">More details are on the post</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=105c996d8c6e" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/the-developer-show-tl-dr-077-105c996d8c6e">The Developer Show ‚Äî TL;DR 077</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Developer Show ‚Äî TL;DR 076]]></title>
            <link>https://medium.com/google-developers/the-developer-show-tl-dr-076-5d5e2910baae?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/5d5e2910baae</guid>
            <category><![CDATA[google-cloud-platform]]></category>
            <category><![CDATA[kubernetes]]></category>
            <category><![CDATA[android-things]]></category>
            <category><![CDATA[game-development]]></category>
            <dc:creator><![CDATA[timothyjordan]]></dc:creator>
            <pubDate>Wed, 26 Jul 2017 20:01:03 GMT</pubDate>
            <atom:updated>2017-07-26T20:01:03.667Z</atom:updated>
            <content:encoded><![CDATA[<p>The Developer Show is where you can stay up to date on all the latest Google Developer news, straight from the experts.</p><p>Have a question? Use #AskDevShow to let us know!</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fvideoseries%3Flist%3DPLOU2XLYxmsII8REpkzsy1bJHj6G1WEVA1&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DKpqRQAkQbqY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FKpqRQAkQbqY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/f1abbc8cb8d007e383fbf0fd775abae8/href">https://medium.com/media/f1abbc8cb8d007e383fbf0fd775abae8/href</a></iframe><h4><a href="https://developers.googleblog.com/2017/07/google-developer-days-europe.html?utm_campaign=devshow_series_gdd_072117&amp;utm_source=gdev&amp;utm_medium=blog">Google Developer Days are coming to Europe</a></h4><p>You can now register for Google Developer Days Europe, taking place on September 5th and 6th, in Krakow, Poland. We‚Äôll showcase our latest developer product and platform updates to help you develop high quality apps, grow &amp; retain an active user base, and tap into tools to earn more. There‚Äôll be technical talks, hands-on training sessions, and 1:1 time with Googlers and members of our Google Developers Experts community. <a href="https://developers.googleblog.com/2017/07/google-developer-days-europe.html?utm_campaign=devshow_series_gdd_072117&amp;utm_source=gdev&amp;utm_medium=blog">The link to register is on the post</a>.</p><h4><a href="https://android-developers.googleblog.com/2017/07/calling-all-indie-developers-in-us.html?utm_campaign=devshow_series_indiegamesfestival_072117&amp;utm_source=gdev&amp;utm_medium=blog">Google Play Indie Games Festival</a></h4><p>Also happening in September is the Google Play Indie Games Festival in San Francisco on the 23rd. If you‚Äôre an indie developer based in the US or Canada and want to submit your game, you have until August 6th. <a href="https://android-developers.googleblog.com/2017/07/calling-all-indie-developers-in-us.html?utm_campaign=devshow_series_indiegamesfestival_072117&amp;utm_source=gdev&amp;utm_medium=blog">Just head on over to the post</a>.</p><h4><a href="https://android-developers.googleblog.com/2017/06/android-things-console-developer-preview.html?utm_campaign=devshow_series_androidthingsconsole_072117&amp;utm_source=gdev&amp;utm_medium=blog">Android Things Console developer preview</a></h4><p>We recently launched a developer preview of the Android Things Console which allows you to manage the software running on your fleet of Android Things IoT devices, including creating factory images, as well as updating the operating system and developer-provided APKs. <a href="https://android-developers.googleblog.com/2017/06/android-things-console-developer-preview.html?utm_campaign=devshow_series_androidthingsconsole_072117&amp;utm_source=gdev&amp;utm_medium=blog">A tour of the console and the features it offers is on the post</a>.</p><h4><a href="https://gsuite-developers.googleblog.com/2017/07/google-people-api-now-supports-updates.html?utm_campaign=devshow_series_googlepeopleapi_072117&amp;utm_source=gdev&amp;utm_medium=blog">Google People API</a></h4><p>The Google People API now has write endpoints that allow you to create, delete, and update a single contact as well as contact group endpoints to read and write contact groups. <a href="https://gsuite-developers.googleblog.com/2017/07/google-people-api-now-supports-updates.html?utm_campaign=devshow_series_googlepeopleapi_072117&amp;utm_source=gdev&amp;utm_medium=blog">Code and screenshots are on the post</a>.</p><h4><a href="https://firebase.googleblog.com/2017/07/cloud-functions-realtime-database.html?utm_campaign=devshow_series_cloudfunctionstriggers_072117&amp;utm_source=gdev&amp;utm_medium=blog">Cloud Functions Realtime Database Triggers</a></h4><p>Starting with the firebase-functions module version 0.5.9, there are now three new types of database triggers you can write: onCreate(), onUpdate(), and onDelete(). <a href="https://firebase.googleblog.com/2017/07/cloud-functions-realtime-database.html?utm_campaign=devshow_series_cloudfunctionstriggers_072117&amp;utm_source=gdev&amp;utm_medium=blog">To see how this can make your code more efficient, check out the post</a>.</p><h4><a href="https://cloudplatform.googleblog.com/2017/07/Google-Cloud-Platform-now-open-in-London.html?utm_campaign=devshow_series_gcplondon_072117&amp;utm_source=gdev&amp;utm_medium=blog">Google Cloud Platform now open in London</a></h4><p>You can now use the new Google Cloud Platform region in London to run applications and store data in London. This is our tenth region and joins our existing European region in Belgium. <a href="https://cloudplatform.googleblog.com/2017/07/Google-Cloud-Platform-now-open-in-London.html?utm_campaign=devshow_series_gcplondon_072117&amp;utm_source=gdev&amp;utm_medium=blog">Details including the available zones and services are on the post</a>.</p><h4><a href="https://cloudplatform.googleblog.com/2017/07/Container-Engine-now-runs-Kubernetes-1-7-to-drive-enterprise-ready-secure-hybrid-workloads.html?utm_campaign=devshow_series_kubernetes1.7_072117&amp;utm_source=gdev&amp;utm_medium=blog">Kubernetes 1.7 on Container Engine</a></h4><p>Google Container Engine now runs Kubernetes 1.7 and includes differentiated features for enterprise security, extensibility, hybrid networking and developer efficiency. <a href="https://cloudplatform.googleblog.com/2017/07/Container-Engine-now-runs-Kubernetes-1-7-to-drive-enterprise-ready-secure-hybrid-workloads.html?utm_campaign=devshow_series_kubernetes1.7_072117&amp;utm_source=gdev&amp;utm_medium=blog">Details are on the post</a>.</p><h4><a href="https://cloudplatform.googleblog.com/2017/07/choosing-the-right-compute-option-in-GCP-a-decision-tree.html?utm_campaign=devshow_series_computeoptiongcp_072117&amp;utm_source=gdev&amp;utm_medium=blog">Choosing the right compute option in GCP</a></h4><p>As developers, when starting a new project on the Google Cloud Platform, you may find yourself trying to decide between different compute options: Google Compute Engine, Google Container Engine, App Engine or even Google Cloud Functions and Firebase. Sound familiar? If so, <a href="https://cloudplatform.googleblog.com/2017/07/choosing-the-right-compute-option-in-GCP-a-decision-tree.html?utm_campaign=devshow_series_computeoptiongcp_072117&amp;utm_source=gdev&amp;utm_medium=blog">this handy decision tree is for you</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5d5e2910baae" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/the-developer-show-tl-dr-076-5d5e2910baae">The Developer Show ‚Äî TL;DR 076</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Testing Room migrations]]></title>
            <link>https://medium.com/google-developers/testing-room-migrations-be93cdb0d975?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/be93cdb0d975</guid>
            <category><![CDATA[testing]]></category>
            <category><![CDATA[software-testing]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[database]]></category>
            <category><![CDATA[software-development]]></category>
            <dc:creator><![CDATA[Florina Muntenescu]]></dc:creator>
            <pubDate>Mon, 24 Jul 2017 15:25:15 GMT</pubDate>
            <atom:updated>2017-07-24T15:26:48.707Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*v4NIKhmuE5uX0ssv6HlxCQ.png" /><figcaption>Is everything where it‚Äôs supposed to be? Test migrations. (Photo by <a href="http://unsplash.com/photos/dzCBKa8rIAM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Dmitri Popov</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a>)</figcaption></figure><p>In a previous post I explained how database migrations with Room work under the hood. We saw that an incorrect migration implementation can lead to either your app crashing or loss of the user‚Äôs data.</p><p><a href="https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929">Understanding migrations with Room</a></p><p>On top of this, the SQL statements you execute in the Migration.migrate method are not checked at compile time, opening the door to more issues. Knowing all of this, testing the migrations becomes an essential task. Room provides the MigrationTestHelper test rule which allows you to:</p><ul><li>Create a database at a given version</li><li>Run a given set of migrations on a database</li><li>Validate the database schema</li></ul><p><em>Note that Room will not validate the data in the database. This is something you need to implement yourself.</em></p><p>Here‚Äôs what you need to know to test Room migrations.</p><h3>Under the hood</h3><p>To test migrations, Room needs to know several things about your current database version: the version number, the entities, the identity hash and the queries for creating and updating the room_master_table. All of these are automatically generated by Room at compile time and stored in a schema JSON file.</p><p>In your build.gradle file you specify a folder to place these generated schema JSON files. As you update your schema, you‚Äôll end up with several JSON files, one for every version. Make sure you commit every generated file to source control. The next time you increase your version number again, Room will be able to use the JSON file for testing.</p><h3>Prerequisites</h3><p>To enable the generation of the JSON file, update your build.gradle file with the following:</p><ol><li>Define the schema location</li></ol><pre>defaultConfig {<br>  javaCompileOptions {<br>            annotationProcessorOptions {<br>                arguments = [&quot;room.schemaLocation&quot;: <br>                                &quot;$projectDir/schemas&quot;.toString()]<br>            }<br>        }<br>}</pre><p>2. Add the schema location to the source sets</p><pre>android {<br>    <br>    sourceSets {<br>        androidTest.assets.srcDirs +=  <br>                           files(&quot;$projectDir/schemas&quot;.toString())<br>    }</pre><p>3. Add the room testing library to the list of dependencies</p><pre>dependencies {</pre><pre>androidTestImplementation    <br>                ‚Äúandroid.arch.persistence.room:testing:1.0.0-alpha5‚Äù</pre><pre>}</pre><h3>Migration test rule</h3><p>Creating the database, schemas, opening and closing the database, running migrations‚Ää‚Äî‚Ääthat‚Äôs a lot of boilerplate code that you would need to write for almost every test. To avoid writing all of this, use the MigrationTestHelper test rule in your migration test class.</p><pre>@Rule<br>public MigrationTestHelper testHelper =<br>        new MigrationTestHelper(<br>                InstrumentationRegistry.<em>getInstrumentation</em>(),<br>                <em>&lt;your_database_class&gt;</em>.class.getCanonicalName(),<br>                new FrameworkSQLiteOpenHelperFactory());</pre><p>The MigrationTestHelper heavily relies on the generated JSON file, both for creating the database and for validating the migration.</p><p>You are able to <strong>create your database in a specific version</strong>:</p><pre>// Create the database with version 2<br>SupportSQLiteDatabase db = <br>                         testHelper.createDatabase(TEST_DB_NAME, 2);</pre><p>You can <strong>run a set of migrations and validate</strong> automatically that the schema was updated correctly:</p><pre>db = testHelper.<strong>runMigrationsAndValidate</strong>(TEST_DB_NAME, 4, validateDroppedTables, MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4);</pre><h3>Implement tests</h3><p>The testing strategy is simple:</p><ol><li>Open the database in a specific version</li><li>Insert some data</li><li>Run the migrations and validate the schema</li><li>Check that the correct data is in the database.</li></ol><p>For example, version 3 of the database adds a new column: date. So, when testing the migration from version 2 to version 3, we check the validity of the data that was inserted in version 2, but also the default value for our new column. Here‚Äôs how our AndroidJUnitTest looks like:</p><pre>@Test<br>public void migrationFrom2To3_containsCorrectData() throws <br>                                                       IOException {<br>    // Create the database in version 2<br>    SupportSQLiteDatabase db = <br>                         <strong>testHelper.createDatabase</strong>(<em>TEST_DB_NAME</em>, 2);<br>    // Insert some data<br>    insertUser(<em>USER</em>.getId(), <em>USER</em>.getUserName(), db);<br>    //Prepare for the next version<br>    db.close();<br><br>    // Re-open the database with version 3 and provide MIGRATION_1_2  <br>    // and MIGRATION_2_3 as the migration process.<br>    <strong>testHelper.runMigrationsAndValidate</strong>(<em>TEST_DB_NAME</em>, 3,   <br>              validateDroppedTables, <em>MIGRATION_1_2</em>, <em>MIGRATION_2_3</em>);<br><br>    // MigrationTestHelper automatically verifies the schema  <br>    //changes, but not the data validity<br>    // Validate that the data was migrated properly.<br>    User dbUser = getMigratedRoomDatabase().userDao().getUser();<br>    <em>assertEquals</em>(dbUser.getId(), <em>USER</em>.getId());<br>    <em>assertEquals</em>(dbUser.getUserName(), <em>USER</em>.getUserName());<br>    // The date was missing in version 2, so it should be null in <br>    //version 3<br>    <em>assertEquals</em>(dbUser.getDate(), null);<br>}</pre><h3>Testing the migration from an SQLiteDatabase implementation to Room</h3><p>I talked before about the steps you need to take to go from a standard SQLiteDatabase implementation to Room, but I didn‚Äôt go into details on how to test the migration implementation.</p><p><a href="https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2">7 Steps To Room</a></p><p>Since the initial database version was not implemented using Room, we don‚Äôt have the corresponding JSON file, therefore we cannot use the MigrationTestHelper to create the database.</p><p>Here‚Äôs what we need to do:</p><ol><li>Extend the SQLiteOpenHelper class and, in onCreate, execute the SQL queries that create your database tables.</li><li>In the @Before method of your tests, create the database.</li><li>In the @After method of your tests, clear the database.</li><li>Use your implementation of SQLiteOpenHelper to insert the data needed for the tests checking the migration from your SQLiteDatabase version to other versions that use Room.</li><li>Use MigrationTestHelper to run the migration and validate the schema.</li><li>Check the validity of the database data.</li></ol><p>Database version 1 was implemented using SQLiteDatabase API, then in version 2 we migrated to Room and, in version 3 we added a new column. A test checking a migration from version 1 to 3 looks like this:</p><pre>@Test<br>public void migrationFrom1To3_containsCorrectData() throws IOException {<br>    // Create the database with the initial version 1 schema and    <br>    //insert a user<br>    <strong>SqliteDatabaseTestHelper</strong>.<em>insertUser</em>(1, <em>USER</em>.getUserName(), sqliteTestDbHelper);<br><br>    // Re-open the database with version 3 and provide MIGRATION_1_2 <br>    // and MIGRATION_2_3 as the migration process.<br>    <strong>testHelper.runMigrationsAndValidate</strong>(<em>TEST_DB_NAME</em>, 3, true,<br>            <em>MIGRATION_1_2</em>, <em>MIGRATION_2_3</em>);<br><br>    // Get the latest, migrated, version of the database<br>    // Check that the correct data is in the database<br>    User dbUser = getMigratedRoomDatabase().userDao().getUser();<br>    <em>assertEquals</em>(dbUser.getId(), 1);<br>    <em>assertEquals</em>(dbUser.getUserName(), <em>USER</em>.getUserName());<br>    // The date was missing in version 2, so it should be null in   <br>    //version 3<br>    <em>assertEquals</em>(dbUser.getDate(), null);<br>}</pre><h3>Show me the code</h3><p>You can check out the implementation in <a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample">this sample app</a>. To ease the comparison every database version was implemented in its own flavor:</p><ol><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations"><strong>sqlite</strong></a>‚Ää‚Äî‚ÄäUses SQLiteOpenHelper and traditional SQLite interfaces.</li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations"><strong>room</strong></a>‚Ää‚Äî‚ÄäReplaces implementation with Room and provides migration to version 2</li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations"><strong>room2</strong></a>‚Ää‚Äî‚ÄäUpdates the DB to a new schema, version 3</li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations"><strong>room3</strong></a>‚Ää‚Äî‚ÄäUpdates the DB to a new, version 4. Provides migration paths to go from version 2 to 3, version 3 to 4 and version 1 to 4.</li></ol><h3>Conclusion</h3><p>With Room, implementing and testing migrations is easy. The MigrationTestHelper test rule allows you to to open your database at any version, to run migrations and validate schemas in only a few lines of code.</p><p>Have you started using Room and implemented migrations? If so, let us know how it went in the comments below.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=be93cdb0d975" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/testing-room-migrations-be93cdb0d975">Testing Room migrations</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Understanding migrations with Room]]></title>
            <link>https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/f01e04b07929</guid>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[data-migration]]></category>
            <category><![CDATA[database]]></category>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[architecture-components]]></category>
            <dc:creator><![CDATA[Florina Muntenescu]]></dc:creator>
            <pubDate>Tue, 18 Jul 2017 22:32:31 GMT</pubDate>
            <atom:updated>2017-07-27T10:22:26.233Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_6oobbwzRm7OFhv2UVlu4Q.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_6oobbwzRm7OFhv2UVlu4Q.png" /><figcaption>Flip the switch and migrate (<a href="https://unsplash.com/photos/qAShc5SV83M">Source</a>)</figcaption></figure><p>Performing database migrations with the SQLite API always made me feel like I was defusing a bomb‚Ää‚Äî‚Ääas if I was one wrong move away from making the app explode in my users‚Äô hands. If you‚Äôre using <a href="https://developer.android.com/topic/libraries/architecture/room.html">Room</a> to handle your database operations, migrations are as easy as flipping a switch.</p><p>With Room, if you change the database schema but don‚Äôt upgrade the version, your app will crash. If you upgrade the version but don‚Äôt provide any migrations your app will crash or, the database tables are dropped and your users will lose their data. Don‚Äôt risk your (app‚Äôs) life by guessing wÃ∂hÃ∂iÃ∂cÃ∂hÃ∂ Ã∂sÃ∂wÃ∂iÃ∂tÃ∂cÃ∂hÃ∂ Ã∂tÃ∂oÃ∂ Ã∂fÃ∂lÃ∂iÃ∂pÃ∂ how to implement migrations. Rather, understand how Room works internally, to migrate your database with confidence.</p><h3>Database migrations under the hood</h3><h4>What SQLite API does</h4><p>SQLite databases handle schema changes with the help of database versioning. More precisely, every time you alter your schema by adding, removing or modifying tables, you have to increase the database version number and update your implementation of SQLiteOpenHelper.onUpgrade method. This is how you tell SQLite what it needs to do when going from an old version to a new version.</p><p>This is also the first call that gets triggered when your app starts working with the database. SQLite will first try to handle the version upgrades and only then it will open the database.</p><h4>What Room does</h4><p>Room provides an abstraction layer to ease SQLite migrations in the form of the <a href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html">Migration</a> class. A Migration class defines the actions that should be performed when migrating from one specific version to another. Room uses its own implementation of SQLiteOpenHelper and, in the onUpgrade method, will trigger the migrations you defined.</p><p>Here‚Äôs what happens when you access the database for the first time:</p><ol><li>The Room database is built</li><li>SQLiteOpenHelper.onUpgrade method is called and Room triggers the migrations</li><li>The database is opened</li></ol><p>If you don‚Äôt provide migrations but you increase the database version, your app might crash or your data may be lost, depending on some circumstances that we will consider below.</p><p>An important part in the migration internals is played by an identity hash String that is used by Room to uniquely identify every database version. This identity hash for the current version is kept in a configuration table managed by Room in your database. So, don‚Äôt be surprised if you peek into your database to see the room_master_table table in there.</p><p>Let‚Äôs take a simple example where we have a users table, with two columns:</p><ul><li>an ID, int, that is also the primary key</li><li>a user name, String</li></ul><p>The users table is part of a database whose version is 1, implemented using the SQLiteDatabase API.</p><p>Let‚Äôs consider that your users are already using this version and you want to start using Room. Let‚Äôs see how Room handles a few scenarios.</p><h3>Migrate SQLite API code to Room</h3><p>In <a href="https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2">another post</a> we looked at migrating your app to Room, let‚Äôs build on this and go into more detail about the data migration. Let‚Äôs assume that the User <a href="https://developer.android.com/topic/libraries/architecture/room.html#entities">entity class</a> and UserDao, the <a href="https://developer.android.com/topic/libraries/architecture/room.html#daos">data access object class</a>, are created, and focus only on the UsersDatabase class, that extends <a href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.html">RoomDatabase</a>.</p><pre>@Database(entities = {User.class}, version = 1)<br>public abstract class UsersDatabase extends RoomDatabase</pre><h4>Scenario 1: keep the database version unchanged‚Ää‚Äî‚Ääapp crashes</h4><p>Here‚Äôs what Room is doing behind the scenes if we keep the database version unchanged and we run our app.</p><p>Step 1: Try to open the database</p><ul><li>Check the identity of the database by comparing the identity hash of the current version with the one saved in the room_master_table. But, since there‚Äôs no identity hash saved, the <strong>app will crash</strong> with an IllegalStateException ‚ùå</li></ul><pre>java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you‚Äôve changed schema but forgot to update the version number. You can simply fix this by increasing the version number.</pre><blockquote>Room will always throw an <strong><em>IllegalStateException</em></strong> if you modify the database schema but do not update the version number.</blockquote><p>Let‚Äôs listen to the error and increment the database version.</p><pre>@Database(entities = {User.class}, <strong>version = 2</strong>)<br>public abstract class UsersDatabase extends RoomDatabase</pre><h4>Scenario 2: version increased, but no migration provided‚Ää‚Äî‚Ääapp crashes</h4><p>Now, when to run the app again Room is doing the following:</p><p>Step 1: Try to upgrade from version 1 (installed on device) to version 2</p><ul><li>Since there are no migrations, the application crashes with IllegalStateException. ‚ùå</li></ul><pre>java.lang.IllegalStateException: A migration from 1 to 2 is necessary. Please provide a Migration in the builder or call fallbackToDestructiveMigration in the builder in which case Room will re-create all of the tables.</pre><blockquote>Room will throw an <em>IllegalStateException</em> if you don‚Äôt provide a Migration.</blockquote><h4>Scenario 3: version increased, fallback to destructive migration enabled‚Ää‚Äî‚Äädatabase is cleared</h4><p>If you don‚Äôt want to provide migrations and you specifically <strong>want your database to be cleared</strong> when you upgrade the version, call fallbackToDestructiveMigration in the database builder:</p><pre><em>database </em>= Room.<em>databaseBuilder</em>(context.getApplicationContext(),<br>                        UsersDatabase.class, &quot;Sample.db&quot;)<br>                .<strong>fallbackToDestructiveMigration()</strong><br>                .build();</pre><p>Now, when to run the app again Room is doing the following:</p><p>Step 1: Try to upgrade from version 1 (installed on device) to version 2</p><ul><li>Since there are no migrations and we fallback to destructive migration, the <strong>tables are dropped</strong> and the identity_hash is inserted. ü§∑</li></ul><p>Step 2: Try to open the database</p><ul><li>Identity hash of the current version and the one saved in the room_master_table are the same. ‚úÖ</li></ul><p>So now, our app doesn‚Äôt crash, but we lose all the data. So be sure that this is how you specifically want to handle migrations.</p><h4>Scenario 4: version increased, migration provided‚Ää‚Äî‚Äädata is kept</h4><p>To keep the user‚Äôs data, we need to implement a migration. Since the schema doesn‚Äôt change, we just need to provide an <strong>empty migration implementation</strong> and tell Room to use it.</p><pre>@Database(entities = {User.class},<strong> </strong>version = 2)<br>public abstract class UsersDatabase extends RoomDatabase {</pre><pre>‚Ä¶</pre><pre>static final Migration <em>MIGRATION_1_2 </em>= new Migration(1, 2) {<br>    @Override<br>    public void migrate(SupportSQLiteDatabase database) {<br>        // Since we didn&#39;t alter the table, there&#39;s nothing else to do here.<br>    }<br>};</pre><pre>‚Ä¶</pre><pre>database =  Room.<em>databaseBuilder</em>(context.getApplicationContext(),<br>        UsersDatabase.class, &quot;Sample.db&quot;)<br>        <strong>.addMigrations(<em>MIGRATION_1_2</em>)</strong><br>        .build();</pre><p>When running the app, Room does the following:</p><p>Step 1: Try to upgrade from version 1 (installed on device) to version 2</p><ul><li>Trigger the empty migration ‚úÖ</li><li>Update the identity hash in the room_master_table ‚úÖ</li></ul><p>Step 2: Try to open the database</p><ul><li>Identity hash of the current version and the one saved in the room_master_table are the same. ‚úÖ</li></ul><p>So now, our app opens, and the user‚Äôs data is migrated! üéâ</p><h3>Migration with simple schema changes</h3><p>Let‚Äôs add another column: last_update, to our users table, by modifying the User class. In the UsersDatabase class we need to do the following changes:</p><p>1. Increase the version to 3</p><pre>@Database(entities = {User.class}, <strong>version = 3</strong>)<br>public abstract class UsersDatabase extends RoomDatabase</pre><p>2. Add a Migration from version 2 to version 3</p><pre>static final Migration <em>MIGRATION_2_3 </em>= new Migration(2, 3) {<br>    @Override<br>    public void migrate(SupportSQLiteDatabase database) {<br>        database.execSQL(&quot;ALTER TABLE users &quot;<br>                + &quot; ADD COLUMN last_update INTEGER&quot;);<br>    }<br>};</pre><p>3. Add the migration to the Room database builder:</p><pre>database = Room.<em>databaseBuilder</em>(context.getApplicationContext(),<br>        UsersDatabase.class, &quot;Sample.db&quot;)<br><strong>        .addMigrations(<em>MIGRATION_1_2</em>, <em>MIGRATION_2_3</em>)<br></strong>        .build();</pre><p>When running the app, the following steps are done:</p><p>Step 1: Try to upgrade from version 2 (installed on device) to version 3</p><ul><li>Trigger the migration and alter the table, keeping user‚Äôs data ‚úÖ</li><li>Update the identity hash in the room_master_table ‚úÖ</li></ul><p>Step 2: Try to open the database</p><ul><li>Identity hash of the current version and the one saved in the room_master_table are the same. ‚úÖ</li></ul><h3>Migrations with complex schema changes</h3><p>SQLite‚Äôs ALTER TABLE‚Ä¶ command is <a href="https://sqlite.org/lang_altertable.html">quite limited</a>. For example, changing the id of the user from an int to a String takes several steps:</p><ul><li>create a new temporary table with the new schema,</li><li>copy the data from the users table to the temporary table,</li><li>drop the users table</li><li>rename the temporary table to users</li></ul><p>Using Room, the Migration implementation looks like this:</p><pre>static final Migration <em>MIGRATION_3_4 </em>= new Migration(3, 4) {<br>    @Override<br>    public void migrate(SupportSQLiteDatabase database) {<br>        // Create the new table<br>        database.execSQL(<br>                &quot;CREATE TABLE users_new (userid TEXT, username TEXT, last_update INTEGER, PRIMARY KEY(userid))&quot;);</pre><pre>// Copy the data<br>        database.execSQL(<br>                &quot;INSERT INTO users_new (userid, username, last_update) SELECT userid, username, last_update FROM users&quot;);</pre><pre>// Remove the old table<br>        database.execSQL(&quot;DROP TABLE users&quot;);</pre><pre>// Change the table name to the correct one<br>        database.execSQL(&quot;ALTER TABLE users_new RENAME TO users&quot;);<br>    }<br>};</pre><h3>Multiple database version increments</h3><p>What if your users have an old version of your app, running database version 1, and want to upgrade to version 4? So far, we have defined the following migrations: version 1 to 2, version 2 to 3, version 3 to 4, so Room will trigger all migrations, one after another.</p><p>Room can handle more than one version increment: we can define a migration that goes from version 1 to 4 in a single step, making the migration process faster.</p><pre>static final Migration <em>MIGRATION_1_4 </em>= new Migration(1, 4) {<br>    @Override<br>    public void migrate(SupportSQLiteDatabase database) {<br>        // Create the new table<br>        database.execSQL(<br>                &quot;CREATE TABLE users_new (userid TEXT, username TEXT, last_update INTEGER, PRIMARY KEY(userid))&quot;);<br>        <br>        // Copy the data<br>        database.execSQL(<br>                &quot;INSERT INTO users_new (userid, username, last_update) SELECT userid, username, last_update FROM users&quot;);</pre><pre>// Remove the old table<br>        database.execSQL(&quot;DROP TABLE users&quot;);</pre><pre>// Change the table name to the correct one<br>        database.execSQL(&quot;ALTER TABLE users_new RENAME TO users&quot;);<br>    }<br>};</pre><p>Next, we just add it to the list of migrations:</p><pre>database = Room.<em>databaseBuilder</em>(context.getApplicationContext(),<br>        UsersDatabase.class, &quot;Sample.db&quot;)<br>        .<strong>addMigrations</strong>(<em>MIGRATION_1_2</em>, <em>MIGRATION_2_3</em>, <em>MIGRATION_3_4</em>, <strong><em>MIGRATION_1_4</em></strong>)<br>        .build();</pre><blockquote>Note that the queries you write in the <em>Migration.migrate</em> implementation are not compiled at run time, unlike the queries from your DAOs. Make sure that you‚Äôre <a href="https://medium.com/google-developers/testing-room-migrations-be93cdb0d975">implementing tests for your migrations</a>.</blockquote><h3>Show me the code</h3><p>You can check out the implementation in <a href="https://github.com/googlesamples/android-architecture-components">this sample app</a>. To ease the comparison every database version was implemented in its own flavor:</p><ol><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations"><strong>sqlite</strong></a>‚Ää‚Äî‚ÄäUses SQLiteOpenHelper and traditional SQLite interfaces.</li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations"><strong>room</strong></a>‚Ää‚Äî‚ÄäReplaces implementation with Room and provides migration to version 2</li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations"><strong>room2</strong></a>‚Ää‚Äî‚ÄäUpdates the DB to a new schema, version 3</li><li><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations"><strong>room3</strong></a>‚Ää‚Äî‚ÄäUpdates the DB to a new, version 4. Provides migration paths to go from version 2 to 3, version 3 to 4 and version 1 to 4.</li></ol><h3>Conclusion</h3><p>Has your schema changed? Just increase the database version and write a new <a href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html">Migration</a> implementation. You‚Äôll ensure that your app won‚Äôt crash and your user‚Äôs data won‚Äôt be lost. It‚Äôs as easy as flipping a switch!</p><p>But, how do you know if you flipped the right switch? How do you test that you migrated from your SQLiteDatabase implementation to Room correctly, that you implemented the correct migration between different database versions, or that your database is indeed starting as it should in a specific version? We talked about <a href="https://developer.android.com/topic/libraries/architecture/room.html#db-migration-testing">testing migrations</a> in detail, covering several different scenarios here:</p><p><a href="https://medium.com/google-developers/testing-room-migrations-be93cdb0d975">Testing Room migrations</a></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f01e04b07929" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929">Understanding migrations with Room</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ViewModels: Persistence, onSaveInstanceState(), Restoring UI State and Loaders]]></title>
            <link>https://medium.com/google-developers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/fc7cc4a6c090</guid>
            <category><![CDATA[android]]></category>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[android-architecture]]></category>
            <dc:creator><![CDATA[Lyla Fujiwara]]></dc:creator>
            <pubDate>Mon, 17 Jul 2017 18:31:25 GMT</pubDate>
            <atom:updated>2017-07-18T00:03:28.694Z</atom:updated>
            <content:encoded><![CDATA[<h3>Introduction</h3><p>In the <a href="https://medium.com/google-developers/viewmodels-a-simple-example-ed5ac416317e">last blog post</a> I explored a simple use case with the new <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html">ViewModel</a> class for saving basketball score data during a configuration change. ViewModels are designed to hold and manage UI-related data in a life-cycle conscious way. ViewModels allow data to survive configuration changes such as screen rotations.</p><p>At this point, you might have a few questions about the breadth of what ViewModels do. In this post I‚Äôll be answering:</p><ul><li><strong>Do ViewModels persist my data?</strong> TL;DR No.<strong> </strong>Persist as normal!</li><li><strong>Are ViewModels a replacement for </strong><a href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)"><strong>onSaveInstanceState</strong></a><strong>?</strong> TL;DR No, but they are related so keep reading.</li><li><strong>How do I use ViewModels to save and restore UI state efficiently?</strong> TL;DR<strong> </strong>You use a combination of ViewModels, onSaveInstanceState() and local persistence.</li><li><strong>Are ViewModels a replacement for Loaders? </strong>TL;DR. Yes, ViewModels used in conjunction with a few other classes can replace Loaders.</li></ul><h3>Do ViewModels persist my data?</h3><p><strong>TL;DR No. </strong>Persist as normal!</p><p>ViewModels hold <strong>transient data used in the UI </strong>but they don‚Äôt persist data. Once the associated UI Controller (fragment/activity) is destroyed or the process is stopped, the ViewModel and all the contained data gets marked for garbage collection.</p><p>Data used over multiple runs of the application should be persisted like normal in a <a href="https://developer.android.com/guide/topics/data/data-storage.html">local database, Shared Preferences, and/or in the cloud</a>. If you want the user to be able to put the app into the background and then come back three hours later to the exact same state, you should also persist data. This is because as soon as your activity goes into the background, your app process can be stopped if the device is running low on memory. There‚Äôs a <a href="https://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle">handy table in the activity class documentation</a> which describes in which activity lifecycle states your app is stoppable:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OlXDJ7WENwiFBgOeKWjH7g.png" /><figcaption><a href="https://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle">Activity lifecycle documentation</a></figcaption></figure><p>As a reminder, when an app processes is stopped due to resource constraints, it‚Äôs stopped without ceremony and <strong>no additional lifecycle callbacks are called. </strong>This means that you can‚Äôt rely on <a href="https://developer.android.com/reference/android/app/Activity.html#onDestroy()">onDestroy</a> being called. You <strong>do not</strong> have a chance to persist data at the time of process shutdown. Therefore, if you want to be the <em>most</em> sure that you won‚Äôt lose data, persist it as soon as the user enters it. This means that even if your app process is shut down due to resource constraints or if the device runs out of battery, the data will be saved. If you‚Äôre willing to concede losing data in instances of sudden device shutdown, you can save the data in the <a href="https://developer.android.com/reference/android/app/Activity.html#onStop()">onStop()</a><strong> </strong>callback<strong>, </strong>which happens right as the activity is going into the background.</p><h3>Are ViewModels a replacement for onSaveInstanceState?</h3><p><strong>TL;DR No, </strong>but they are related so keep reading.</p><p>To understand the subtleties of this difference, it‚Äôs helpful to understand the difference between <a href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle, android.os.PersistableBundle)">onSaveInstanceState()</a> and <a href="https://developer.android.com/reference/android/app/Fragment.html#setRetainInstance(boolean)">Fragment.setRetainInstance(true)</a></p><p><strong>onSaveInstanceState(): </strong>This callback is meant to retain a <strong>small </strong>amount of UI related data in two situations:</p><ul><li>The app‚Äôs process is stopped when it‚Äôs in the background due to memory constraints.</li><li>Configuration changes.</li></ul><p>onSaveInstanceState() is called in situations in which the activity is <a href="https://developer.android.com/reference/android/app/Activity.html#onStop()">stopped</a>, but not <a href="https://developer.android.com/reference/android/app/Activity.html#finish()">finished</a>, by the system. It is <strong>not</strong> called when the user explicitly closes the activity or in other cases when <a href="https://developer.android.com/reference/android/app/Activity.html#finish()">finish()</a> is called.</p><p>Note that a lot of UI data is automatically saved and restored for you:</p><blockquote>‚ÄúThe default implementation of this method saves transient information about the state of the activity‚Äôs view hierarchy, such as the text in an <a href="https://developer.android.com/reference/android/widget/EditText.html">EditText</a> widget or the scroll position of a <a href="https://developer.android.com/reference/android/widget/ListView.html">ListView</a> widget.‚Äù‚Ää‚Äî‚Ää<a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html#saras">Saving and Restoring Instance State Documentation</a></blockquote><p>These are also good examples of the type of data that is meant to be stored in onSaveInstanceState(). onSaveInstanceState() <a href="https://developer.android.com/guide/topics/resources/runtime-changes.html#RetainingAnObject">is not designed to</a> store large amounts of data, such as bitmaps.onSaveInstanceState() is designed to store data that is small, related to the UI and not complicated to serialize or deserialize. Serialization can consume lots of memory if the objects being serialized are complicated. Because this process happens on the main thread during a configuration change, it needs to be fast so that you don‚Äôt drop frames and cause visual stutter.</p><p><strong>Fragment.setRetainInstance(true)</strong>: The <a href="https://developer.android.com/guide/topics/resources/runtime-changes.html#RetainingAnObject">Handling Configuration Changes documentation</a> describes a process for storing data during a configuration change using a retained fragment. This <em>sounds</em> less useful than onSaveInstanceState() which covers both configuration changes as well as process shutdown. The usefulness of creating a retained fragment is that it‚Äôs meant to retain large sets of data such as images or to retain complex objects like network connections.</p><p><strong>ViewModels only survive configuration change-related destruction; they do not survive the process being stopped.</strong> This makes ViewModels a replacement for using a fragment with setRetainInstance(true) (in fact ViewModels use a fragment with <a href="https://developer.android.com/reference/android/app/Fragment.html#setRetainInstance(boolean)">setRetainInstance</a> set to true behind the scenes).</p><h4>Additional ViewModel benefits</h4><p>ViewModels and onSaveInstanceState() address UI data in very different ways. onSaveInstanceState() is a lifecycle callback, whereas ViewModels fundamentally change the way UI data is managed in your app. Here are a few more thoughts on the benefits of using ViewModel in addition to onSaveInstanceState():</p><ul><li><strong>ViewModels encourage good architectural design. Your data is separated from your UI code</strong>, which makes the code more modular and simplifies testing.</li><li>onSaveInstanceState() is designed to save a small amount of transient data, but not complex lists of objects or media data.<strong> A ViewModel can delegate the loading of complex data and also act as temporary storage once this data is loaded</strong>.</li><li>onSaveInstanceState() is called during configuration changes and when the activity goes into the background; in both of these cases you actually do <strong>not</strong> need to reload or process the data if you keep it in a ViewModel.</li></ul><h3>How do I use ViewModels to save and restore UI state efficiently?</h3><p><strong>TL;DR </strong>You use <strong>a combination of ViewModels, </strong><strong>onSaveInstanceState() and local persistence</strong>.<strong> </strong>Read on to see how.</p><p>It‚Äôs important that your activity maintains the state a user expects, even as it is rotated, shut down by the system or restarted by the user. As I just mentioned, it‚Äôs also important that you don‚Äôt clog up onSaveInstanceState with complex objects. You also don‚Äôt want to reload data from the database when you don‚Äôt need to. Let‚Äôs look at an example of an activity that allows you to search through your library of songs:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*KjsvodQeJCZwSWiwtPET2g.png" /><figcaption>Example of the clean state of the activity and the state after a search</figcaption></figure><p>There are two general ways a user can leave an activity, and two different outcomes the user will expect:</p><ul><li>The first is if the user <strong>completely closes</strong> the activity. A user can completely close the activity if they swipe an activity off of the <a href="https://developer.android.com/guide/components/activities/recents.html">recents screen</a> or if a user <a href="https://developer.android.com/training/design-navigation/ancestral-temporal.html">navigates up or back</a> out of an activity. The assumption in these cases is that <strong>the user has permanently navigated away from the activity, and if they ever re-open the activity, they will expect to start from a clean state</strong>. For our song app, if a user completely closes the song search activity and later re-opens the activity, the song search box will be cleared and so will the search results.</li><li>On the other hand, if a user rotates the phone or puts the activity in the background and then comes back to it, the user expects that the search results and song they searched for are there, exactly as before. There are a few ways the user could put the activity in the background. They could press the home button or navigate somewhere else in the app. Or they could receive a phone call or notification in the middle of looking at search results. In the end, though, the user expects when they come back to the activity, that the state is the same as they left it.</li></ul><p>To implement this behavior in both situations, you will use local persistence, ViewModels and onSaveInstanceState() together. Each will store different data the activity uses:</p><ul><li><strong>Local persistence</strong> is used for storing all data you don‚Äôt want to lose if you open and close the activity.<br><strong>Example:</strong> The collection of all song objects, which could include audio files and metadata</li><li><strong>ViewModels </strong>are used for storing all the data needed to display the associated UI Controller.<br><strong>Example:</strong> The results of the most recent search, the most recent search query</li><li><strong>onSaveInstanceState</strong> is used for storing a small amount of data needed to easily reload activity state if the UI Controller is stopped and recreated by the system. Instead of storing complex objects here, persist the complex objects in local storage and store a unique ID for these objects in onSaveInstanceState().<br><strong>Example:</strong> The most recent search query</li></ul><p>In the song search example, here‚Äôs how different events should be handled:</p><p><strong>When the user adds a song‚Ää‚Äî‚Ää</strong>The ViewModel will immediately delegate persisting this data locally. If this newly added song is something that should be shown in the UI, you should also update the data in ViewModel to reflect the addition of the song. Remember to do all database inserts off of the main thread.</p><p><strong>When the user searches for a song‚Ää‚Äî‚Ää</strong>Whatever complex song data you load from the database for the UI Controller should be immediately stored in the ViewModel. You should also save the search query itself in the ViewModel.</p><p><strong>When the activity goes into the background and the activity is stopped by the system‚Ää‚Äî‚Ää</strong>When the activity goes into the background, onSaveInstanceState() will be called. You should save the search query in the onSaveInstanceState() bundle. This small amount of data is easy to save. It‚Äôs also all the information you need to get the activity back into its current state.</p><p><strong>When the activity is created‚Ää</strong>‚Äî‚ÄäThere are three different ways this could happen:</p><ul><li><strong>The activity is created for the first time</strong>: In this case, you‚Äôll have no data in the onSaveInstanceState() bundle and an empty ViewModel. When creating the ViewModel, you‚Äôll pass an empty query and the ViewModel will know that there‚Äôs no data to load yet. The activity will start in a clean empty state.</li><li><strong>The activity is created after being stopped by the system</strong>: The activity will have the query saved in an onSaveInstanceState() bundle. The activity should pass the query to the ViewModel. The ViewModel will see that it has no search results cached and will delegate loading the search results, using the given search query.</li><li><strong>The activity is created after a configuration change</strong>: The activity will have the query saved in an onSaveInstanceState() bundle AND the ViewModel will already have the search results cached. You pass the query from the onSaveInstanceState() bundle to the ViewModel, which will determine that it already has loaded the necessary data and that it does <strong>not</strong> need to re-query the database.</li></ul><p>This is one sane way to handle saving and restoring activity state. Depending on your activity implementation, you might not need to use onSaveInstanceState() at all. For example, some activities don‚Äôt open in a clean state after the user closes them. Currently, when I close and re-open Chrome on Android, it takes me back to the exact webpage I was looking at before closing it. If your activity behaves this way, you can ditch onSaveInstanceState() and instead persist everything locally. In the song searching example, that would mean persisting the most recent query, for example, in <a href="https://developer.android.com/reference/android/content/SharedPreferences.html">Shared Preferences</a>.</p><p>Additionally, when you open an activity from an intent, the bundle of extras is delivered to you on both configuration changes and when the system restores an activity. If the search query were passed in as an intent extra, you could use the extras bundle instead of the onSaveInstanceState() bundle.</p><p>In both of these scenarios, though, you‚Äôd still use a ViewModel to avoid wasting cycles reloading data from the database during a configuration change!</p><h3>Are ViewModels a replacement for Loaders?</h3><p><strong>TL;DR.</strong> Yes, ViewModels used in conjunction with a few other classes can replace Loaders.</p><p><a href="https://developer.android.com/guide/components/loaders.html"><strong>Loaders</strong></a> are for loading data for UI Controllers. In addition, Loaders can survive configuration changes, if, for example, you rotate the device in the middle of a load. This sounds familiar!</p><p>A common use case for Loaders, in particular <a href="https://developer.android.com/reference/android/content/CursorLoader.html">CursorLoaders</a>, is to have the Loader observe the content of a database and keep the data the UI displays in sync. Using a CursorLoader, if a value in the database changes, the Loader will automatically trigger a reload of the data and update the UI.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*QuZeqCSgKlrfD7CGQq1laA.png" /></figure><p>ViewModels, used with other Architecture Components, <a href="https://developer.android.com/topic/libraries/architecture/livedata.html">LiveData</a> and <a href="https://developer.android.com/topic/libraries/architecture/room.html">Room</a>, can replace Loaders. The ViewModel ensures that the data can survive a configuration change. LiveData ensures that your UI can update when the data updates. Room ensures that when your database updates, your LiveData is notified.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Zc2mtVLw7y10MFZq4za7EA.png" /></figure><p>Loaders are implemented as callbacks within your UI Controller, so an added benefit of ViewModels is they detangle your UI Controller and data loading. This makes you have fewer strong references between classes.</p><p>There are a few approaches to using ViewModels and LiveData to load data:</p><ul><li>In <a href="https://medium.com/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4">this blog post</a>, <a href="https://medium.com/u/51a4f24f5367">Ian Lake</a> outlines how you can use a ViewModel and LiveData to replace an <a href="https://developer.android.com/reference/android/content/AsyncTaskLoader.html">AsyncTaskLoader</a>.</li><li>As your code gets more complex, you can consider having the actual data loading take place in a separate class. The purpose of a ViewModel class is to contain data for a UI controller such that that data survives configuration changes. Loading, persisting, and managing data are complicated functions that are outside of the scope of what a ViewModel traditionally does. The <a href="https://developer.android.com/topic/libraries/architecture/guide.html#fetching_data">Guide to Android App Architecture</a> suggests building a <strong>repository </strong>class.</li></ul><blockquote>‚ÄúRepository modules are responsible for handling data operations. They provide a clean API to the rest of the app. They know where to get the data from and what API calls to make when data is updated. You can consider them as mediators between different data sources (persistent model, web service, cache, etc.).‚Äù‚Ää‚Äî‚Ää<a href="https://developer.android.com/topic/libraries/architecture/guide.html#fetching_data">Guide to App Architecture</a></blockquote><h3>Conclusion and further learning</h3><p>In this post, I answered a few questions about what the ViewModel class is and what it‚Äôs not. The key takeaways are:</p><ul><li>ViewModels are not a replacement for persistence‚Ää‚Äî‚Ääpersist your data like normal when it‚Äôs changed.</li><li>ViewModels are not a replacement for onSaveInstanceState() because they only survive configuration change related destruction; they do not survive the OS stopping the app‚Äôs process.</li><li>onSaveInstanceState() is not meant for complex data that require lengthy serialization/deserialization.</li><li>To efficiently save and restore UI state, use a combination of persistence, onSaveInstanceState() and ViewModels. Complex data is saved in local persistence and onSaveInstanceState() is used to store unique identifiers to that complex data. ViewModels store the complex data in memory after it is loaded.</li><li>In this scenario, ViewModels still retain the data when the activity is rotated or goes into the background, which is something that you can‚Äôt easily do by using purely onSaveInstanceState().</li><li>ViewModels and LiveData, used in conjunction, can replace Loaders. You can use Room to replace CursorLoader functionality.</li><li>Repository classes are created to support a scalable architecture for loading, caching and syncing data.</li></ul><p>Want more ViewModel-ly goodness? Check out:</p><ul><li><a href="https://developer.android.com/topic/libraries/architecture/adding-components.html">Instructions for adding the gradle dependencies</a></li><li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html">ViewModel</a> documentation</li><li>Guided ViewModel practice with the <a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0">Lifecycles Codelab</a></li><li>Helpful samples that include ViewModel [<a href="https://github.com/googlesamples/android-architecture-components">Architecture Components</a>] [<a href="https://github.com/googlesamples/android-architecture/tree/dev-todo-mvvm-live/">Architecture Blueprint using Lifecycle Components</a>]</li><li>The <a href="https://developer.android.com/topic/libraries/architecture/guide.html">Guide to App Architecture</a></li></ul><p>The architecture components were created based on your feedback. If you have questions or comments about ViewModel or any of the architecture components, check out our <a href="https://developer.android.com/topic/libraries/architecture/feedback.html">feedback page</a>. Questions about this series? Leave a comment!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fc7cc4a6c090" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090">ViewModels: Persistence, onSaveInstanceState(), Restoring UI State and Loaders</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Migrating an Android project to Kotlin]]></title>
            <link>https://medium.com/google-developers/migrating-an-android-project-to-kotlin-f93ecaa329b7?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/f93ecaa329b7</guid>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[androiddev]]></category>
            <category><![CDATA[software-development]]></category>
            <category><![CDATA[kotlin]]></category>
            <dc:creator><![CDATA[Ben Weiss]]></dc:creator>
            <pubDate>Wed, 12 Jul 2017 12:14:57 GMT</pubDate>
            <atom:updated>2017-07-14T09:37:23.846Z</atom:updated>
            <content:encoded><![CDATA[<p>A while ago we open sourced <a href="https://github.com/googlesamples/android-topeka">Topeka</a>, an Android quiz app.<br>It is tested, using <a href="https://github.com/googlesamples/android-topeka/tree/master/app/src/androidTest/java/com/google/samples/apps/topeka">integration tests</a> and <a href="https://github.com/googlesamples/android-topeka/tree/master/app/src/test/java/com/google/samples/apps/topeka">unit tests</a>.<br>And it is purely written in Java. Well‚Ä¶ it was</p><h3>What‚Äôs the name of the island off the coast of St Petersburg? _ _ _ _ _ _</h3><p>At Google I/O 2017 we announced official <a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/">support for the Kotlin programming language</a>. That‚Äôs when I started migrating the code base away from Java, <strong>learning Kotlin on the way.</strong></p><blockquote>Not that this migration was necessary from a technological standpoint. The app is solid as it stands, but mainly to satisfy my curiosity; Topeka serving as my vehicle to learn a new language.</blockquote><p>If you‚Äôre curious you can jump straight into the <a href="https://github.com/googlesamples/android-topeka/tree/kotlin">source code on GitHub</a>.<br><em>For now the code is on a separate branch, but we‚Äôre planning to merge the Kotlin code into master at some point in the future.</em></p><p>This post gathers some of the key parts I have found during the migration. It also shows some of the things I found useful while learning a new programming language for Android development.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*oML2dls3WxjhTnR4a_TTRg.png" /><figcaption>It still looks the same</figcaption></figure><h3>üîë Key take aways</h3><ul><li>Kotlin is a fun, powerful language</li><li>Testing gives peace of mind</li><li>Platform specific idioms are scarce</li></ul><h3>Initial migration to Kotlin</h3><style>body[data-twttr-rendered="true"] {background-color: transparent;}.twitter-tweet {margin: auto !important;}</style><blockquote class="twitter-tweet" data-conversation="none" data-align="center" data-dnt="true"><p>Step 1: Select all files, step 2: Convert Java file to Kotlin, step 3: you can hang out with all the cool developers now. #androidBadvice</p><p>&#x200a;&mdash;&#x200a;<a href="https://twitter.com/anddev_badvice/status/864998931817615360">@anddev_badvice</a></p></blockquote><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script>function notifyResize(height) {height = height ? height : document.documentElement.offsetHeight; var resized = false; if (window.donkey && donkey.resize) {donkey.resize(height); resized = true;}if (parent && parent._resizeIframe) {var obj = {iframe: window.frameElement, height: height}; parent._resizeIframe(obj); resized = true;}if (window.location && window.location.hash === "#amp=1" && window.parent && window.parent.postMessage) {window.parent.postMessage({sentinel: "amp", type: "embed-size", height: height}, "*");}if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.resize) {window.webkit.messageHandlers.resize.postMessage(height); resized = true;}return resized;}twttr.events.bind('rendered', function (event) {notifyResize();}); twttr.events.bind('resize', function (event) {notifyResize();});</script><script>if (parent && parent._resizeIframe) {var maxWidth = parseInt(window.frameElement.getAttribute("width")); if ( 500  < maxWidth) {window.frameElement.setAttribute("width", "500");}}</script><p>Steps 1 and 2 are kind of valid for getting started with Kotlin.<br>I‚Äôll figure out how that 3rd step will play out, though.</p><h4>For Topeka the route was more like this:</h4><ol><li>Read up on the <a href="https://kotlinlang.org/docs/reference/basic-syntax.html">basic syntax of Kotlin</a></li><li>Go through the <a href="https://github.com/Kotlin/kotlin-koans">Koans</a> to gain basic familiarity with the language</li><li>Convert files, one by one, via ‚Äú‚å•‚áß‚åòK‚Äù, make sure tests still pass</li><li>Go over the Kotlin files and make them more idiomatic</li><li>Repeat step 4 until you and your code reviewers are happy</li><li>Ship it</li></ol><h3>Interoperability</h3><p><strong>Going step by step is a sensible approach.<br></strong>Kotlin compiles down to Java byte code and the two languages are interoperable. Also it‚Äôs possible to have both languages within the same project. So it‚Äôs not necessary to migrate all code to another language.</p><p>But if that‚Äôs your goal, it makes sense to do so iteratively. This way it‚Äôs more feasible to maintain a stable application throughout the migration process and learn as you go along.</p><h3>Tests ease your mind</h3><p>Having a suite of unit and integration tests has many benefits.<br>In most cases they are there to provide confidence that changes have not broken existing behaviour.</p><p>Starting off with the less complex data classes was the clear choice for me. <br>They are being used throughout the project, yet their complexity is comparatively low. This makes them an ideal starting point to set off the journey into a new language.</p><p>After migrating some of these using the Kotlin code converter, which is built into Android Studio, executing tests and making them pass, I worked my way up until eventually ending up migrating the tests themselves to Kotlin.</p><p>Without tests, I would have been required to go through the touched features after each change, and manually verify them.<br>By having this automated it was a lot quicker and easier to move through the codebase, migrating code as I went along.</p><p>So, if you don‚Äôt have your app tested properly yet, there‚Äôs one more reason to do so right here. üëÜ</p><h3>Generated code is not always nice to look at ‚ÄºÔ∏è</h3><p>After an initial round of <em>mostly</em> automated migration, I went on to read up on the <a href="https://kotlinlang.org/docs/reference/coding-conventions.html">Kotlin style guide</a>. This page made it clear to me that there‚Äôs still a long way ahead.</p><p>The converter does a good job, overall. There are a lot of language idioms and features which are not being taken into account during the automated process, though. Which is probably for the better, since translating is tricky. Especially if one language contains more features or achieves similar things in a different way.</p><p>For further reading on the Kotlin converter, <a href="https://medium.com/u/9a3b7ded03e0">Benjamin Baxter</a> has written about his experience:</p><p><a href="https://medium.com/google-developers/lessons-learned-while-converting-to-kotlin-with-android-studio-f0a3cb41669">Lessons learned while converting to Kotlin with Android Studio</a></p><h3>‚ÄºÔ∏è ‚Åâ</h3><p>After the automatic conversion I ended up with a lot of ? and !!.<br>These are used to make a value nullable and assert that something is not null. Which in turn can lead to a NullPointerException.<br>And I couldn‚Äôt help but think of a very fitting quote:</p><blockquote><em>‚ÄòMultiple exclamation marks,‚Äô he went on, shaking his head, ‚Äòare a sure sign of a diseased mind.‚Ää‚Äî‚Ää</em><a href="https://wiki.lspace.org/mediawiki/Multiple_exclamation_marks"><em>Terry Pratchett</em></a></blockquote><p>In many cases a value doesn‚Äôt have to be nullable, so null checks can be removed. It‚Äôs not even necessary to initialise all values directly within a constructor. Instead lateinit or delegate initialisation can be used.</p><p>This doesn‚Äôt work for everything though:</p><style>body[data-twttr-rendered="true"] {background-color: transparent;}.twitter-tweet {margin: auto !important;}</style><blockquote class="twitter-tweet" data-conversation="none" data-align="center" data-dnt="true"><p><a href="http://twitter.com/alexjlockwood" target="_blank" title="Twitter profile for @alexjlockwood">@alexjlockwood</a> <a href="http://twitter.com/_rpiel" target="_blank" title="Twitter profile for @_rpiel">@_rpiel</a> Only be careful by not using lateinit for View vars in fragment/controller, it will leak activity, because it needs nullify in onDestoyView</p><p>&#x200a;&mdash;&#x200a;<a href="https://twitter.com/dimsuz/status/883052997688930304">@dimsuz</a></p></blockquote><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script>function notifyResize(height) {height = height ? height : document.documentElement.offsetHeight; var resized = false; if (window.donkey && donkey.resize) {donkey.resize(height); resized = true;}if (parent && parent._resizeIframe) {var obj = {iframe: window.frameElement, height: height}; parent._resizeIframe(obj); resized = true;}if (window.location && window.location.hash === "#amp=1" && window.parent && window.parent.postMessage) {window.parent.postMessage({sentinel: "amp", type: "embed-size", height: height}, "*");}if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.resize) {window.webkit.messageHandlers.resize.postMessage(height); resized = true;}return resized;}twttr.events.bind('rendered', function (event) {notifyResize();}); twttr.events.bind('resize', function (event) {notifyResize();});</script><script>if (parent && parent._resizeIframe) {var maxWidth = parseInt(window.frameElement.getAttribute("width")); if ( 500  < maxWidth) {window.frameElement.setAttribute("width", "500");}}</script><p>So I had to go back and make my view members nullable.</p><p>In these and other cases you will still have to check, whether something is null. Using <em>supportActionBar</em>?.setDisplayShowTitleEnabled(false) only executes the part after the question mark if there is a supportActionBar.<br>This means a lot less if statement based null checks. üî•</p><p>Also executing code with some of the stdlib functions directly on the non-null variable can be handy:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fa655a98326debe386c78ecacc5d8008/href">https://medium.com/media/fa655a98326debe386c78ecacc5d8008/href</a></iframe><h3>Incrementally becoming more idiomatic</h3><p>Going through the generated code and making it more idiomatic, as well as getting reviewer feedback made it obvious that Kotlin is a powerful language. It made things readable and concise.</p><p>Let‚Äôs take a look at some examples that I came across.</p><h4>Reading less is not always a bad thing</h4><p>Let‚Äôs take an adapter‚Äôs getView as example:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/11c96ea150d03d056e7310a6918f4d82/href">https://medium.com/media/11c96ea150d03d056e7310a6918f4d82/href</a></iframe><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b411b65d04199c7804b61efca53671d3/href">https://medium.com/media/b411b65d04199c7804b61efca53671d3/href</a></iframe><p>These two code snippets do the <em>same thing</em>:<br>Check, whether convertView is null and either create a new view within createView(...) or return convertView. Both also call bindView(...).</p><p>Both snippets, are equally legible. And boiling things down from 8 lines to mere 2 lines? <strong>Render me impressed.</strong></p><h4>Data classes are magical ü¶Ñ</h4><p>To make it even more obvious how concise Kotlin can be, data classes easily manage to get rid of some verbosity:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e9cf398f13bf1ef3672ca8c768a88ac0/href">https://medium.com/media/e9cf398f13bf1ef3672ca8c768a88ac0/href</a></iframe><p>Now, let‚Äôs look at that in Kotlin:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e964a61cc1886e33948dfdd75cb53aa1/href">https://medium.com/media/e964a61cc1886e33948dfdd75cb53aa1/href</a></iframe><p>Yes, that‚Äôs 55 lines of code less, expressing the same thing. That‚Äôs the <a href="https://kotlinlang.org/docs/reference/data-classes.html">magic of data classes</a>.</p><h4>Extending functionality</h4><p>This is where things get slightly weird from a traditional Android developer‚Äôs point of view. Kotlin allows creating your own DSL within a given scope.</p><p><strong>Let‚Äôs see how that works</strong></p><p>At times within Topeka it makes sense to pass around booleans in a Parcel. This is not directly supported by the Android Framework APIs.<br>In the initial implementation it was necessary to explicitly call a utility class‚Äô method like such ParcelableHelper.writeBoolean(parcel, value).<br>With Kotlin, <a href="https://kotlinlang.org/docs/reference/extensions.html">extension functions</a> solve that once and for all:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/828546302cca007542eabba2d97763f1/href">https://medium.com/media/828546302cca007542eabba2d97763f1/href</a></iframe><p>Having this written in one place, makes it possible to call parcel.writeBoolean(value) and parcel.readBoolean() directly, as if it were part of the framework. If Android Studio would not highlight extension functions differently, they were almost not noticeable.</p><p><strong>Extending functionality makes things easier to read.</strong> Let‚Äôs take a look at another example: replacing a Fragment in a view hierarchy</p><p>In the Java world this would look something like this:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7ad6260dbcea5d35811ba431a4b2a730/href">https://medium.com/media/7ad6260dbcea5d35811ba431a4b2a730/href</a></iframe><p>That‚Äôs actually not too bad. But you‚Äôll have to write this code, <em>every single time</em> a fragment will be replaced. Or create a method somewhere, for example in yet another Utils class.</p><p>With Kotlin, an extension function makes it possible to simply call replaceFragment(R.id.container, MyFragment()) to replace a fragment within any FragmentActivity within the project, by adding this code:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bccf17b743d7a24cc92d9e21c290e850/href">https://medium.com/media/bccf17b743d7a24cc92d9e21c290e850/href</a></iframe><h4>Less ceremony, more functionality</h4><p><strong>Higher order functions</strong> blew my mind.<br>Yes, I know that this is not a new concept in general. But for the old fashioned Android developer, it actually is. I had heard of them before and have seen them written, but making use of them within my own code is a different story.</p><p>Within several places in Topeka, I am relying on an OnLayoutChangeListener to inject behaviour. In a pre-Kotlin world this would usually result in an anonymous class, with some duplicated code.</p><p>After the migration, all that‚Äôs required to call is:<br>view.onLayoutChange { myAction() }</p><p>The ceremony around that has been encapsulated in this extension function:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e32be69eadbf4c6817f374c8e4953ba8/href">https://medium.com/media/e32be69eadbf4c6817f374c8e4953ba8/href</a></iframe><p>Giving another example, this behaviour can also be applied to things like database transactions:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/30b2da0e22a2d06aad852d41689ac40f/href">https://medium.com/media/30b2da0e22a2d06aad852d41689ac40f/href</a></iframe><p>Now, instead of performing the whole dance to begin and end a transaction, all the user of this API has to call is db.transact { operation() }.</p><p><a href="https://twitter.com/pacoworks/status/885147451757350912">Update via Twitter</a>: UsingSQLiteDatabase.() instead of just () to pass in a function allows working on the database directly within the operation(). üî•</p><p>I could go on, but you get the gist.</p><blockquote>Higher order functions and extensions are handy to make a project easier to read and more fun to work with by removing unnecessary verbosity, adding functionality and hiding implementation details.</blockquote><h3>Things to discover</h3><p>Throughout the conversion I have not come across many best practices for Android development just yet. So far I have mostly been sticking to the style guide and code conventions.</p><p>That may be because I am still new to the language or because there hasn‚Äôt been that much investment in gathering and publicising these yet. Maybe there is a collection which I am yet to come across, but it seems that there is quite some space for platform specific idioms.<br>If you‚Äôre aware of collections like this, please add them to the comments.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f93ecaa329b7" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/migrating-an-android-project-to-kotlin-f93ecaa329b7">Migrating an Android project to Kotlin</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Implementing Adaptive Icons]]></title>
            <link>https://medium.com/google-developers/implementing-adaptive-icons-1e4d1795470e?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/1e4d1795470e</guid>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[design]]></category>
            <category><![CDATA[motion-design]]></category>
            <category><![CDATA[iconography]]></category>
            <category><![CDATA[android]]></category>
            <dc:creator><![CDATA[Nick Butcher]]></dc:creator>
            <pubDate>Mon, 10 Jul 2017 11:12:31 GMT</pubDate>
            <atom:updated>2017-07-26T09:32:22.821Z</atom:updated>
            <content:encoded><![CDATA[<p>Android O introduces an new application icon format called <a href="https://developer.android.com/preview/features/adaptive-icons.html">adaptive icons</a>, intended to make all icons on a device more coherent. This post will look into how to build adaptive icons for your app. It‚Äôs unlikely that many apps will be minSdkVersion 26 any time soon, so this post will also examine techniques for adding this additional icon as efficiently as possible.</p><p>It‚Äôs also worth pointing out that Android Studio 3.0 includes a <a href="https://developer.android.com/preview/features/adaptive-icons.html#studio">new wizard</a> to help you to create adaptive icons which we won‚Äôt cover here; we‚Äôll stick to the fundamental format and techniques.</p><p>If you‚Äôre interested in the back story of this format or how to design an adaptive icon the check out these posts:</p><ul><li><a href="https://medium.com/@crafty/understanding-android-adaptive-icons-cee8a9de93e2">Understanding Android Adaptive Icons</a></li><li><a href="https://medium.com/@crafty/designing-adaptive-icons-515af294c783">Designing Adaptive Icons</a></li></ul><h4>Basics</h4><p>Adaptive icons are a new drawable type, namely <a href="https://developer.android.com/reference/android/graphics/drawable/AdaptiveIconDrawable.html">AdaptiveIconDrawable</a>. You‚Äôll likely never need to work with the class directly, but to define it in XML and point to it from your manifest. You can do so using this format:</p><pre>&lt;adaptive-icon&gt;<br>  &lt;background android:drawable=&quot;@[drawable|mipmap|color]/bar&quot;/&gt;<br>  &lt;foreground android:drawable=&quot;@[drawable|mipmap|color]/foo&quot;/&gt;&lt;/adaptive-icon&gt;</pre><p>Each drawable <strong>must</strong> be 108dp*108dp in size; background drawables must be opaque whilst foregrounds can contain transparency.</p><h4>Actually minSDK is 26</h4><p>Because adaptive icons are only used on API 26+, you can rely on certain features being available to you. Specifically pretty capable VectorDrawable support.</p><blockquote>Unfortunately you can‚Äôt use custom drawable inflation; as your icon will be loaded by other apps‚Äô processes, you need to stick to platform drawable types.</blockquote><p>Utilizing vectors is attractive as it allows us to specify the drawable once in a very compact format. That means it will be crisp at every density without bloating your APK.</p><p>In particular, many developers do not seem to have taken advantage of VectorDrawable&#39;s support for gradients. On this topic, I‚Äôd recommend reading <a href="https://medium.com/u/51a4f24f5367">Ian Lake</a>‚Äôs recent post on implementing an adaptive icon which covers the basics.</p><p><a href="https://medium.com/@ianhlake/vectordrawable-adaptive-icons-3fed3d3205b5">VectorDrawable Adaptive Icons</a></p><p><a href="https://medium.com/u/51a4f24f5367">Ian</a> shows how to use a simple linear gradient, but VectorDrawable has a few more nifty tricks. Here‚Äôs an example of implementing a ‚Äòlong-shadow‚Äô using a radial gradient with multiple color stops. I‚Äôm also using the <a href="https://developer.android.com/guide/topics/resources/complex-xml-resources.html">inline resource syntax</a> which lets you embed what would be multiple files into a single file (via AAPT tricks, commonly used with AnimatedVectorDrawables):</p><pre>&lt;vector ...&gt;</pre><pre>  &lt;path android:name=&quot;long-shadow&quot;<br>        android:pathData=&quot;...&quot;&gt;</pre><pre>    &lt;aapt:attr name=&quot;android:fillColor&quot;&gt;</pre><pre>      &lt;gradient<br>          android:type=&quot;radial&quot;<br>          android:centerX=&quot;54&quot;<br>          android:centerY=&quot;54&quot;<br>          android:gradientRadius=&quot;76.37&quot;&gt;</pre><pre>        &lt;!-- 15% black from center to 32% stop --&gt;<br>        &lt;item android:offset=&quot;0.0&quot; android:color=&quot;#26000000&quot; /&gt;<br>        &lt;item android:offset=&quot;0.32&quot; android:color=&quot;#26000000&quot; /&gt;</pre><pre>        &lt;!-- 2% black at 62% stop --&gt;<br>        &lt;item android:offset=&quot;0.62&quot; android:color=&quot;#05000000&quot; /&gt;</pre><pre>        &lt;!-- fade to transparent --&gt;<br>        &lt;item android:offset=&quot;1.0&quot; android:color=&quot;#00000000&quot; /&gt;</pre><pre>      &lt;/gradient&gt;</pre><pre>    &lt;/aapt:attr&gt;</pre><pre>  &lt;/path&gt;</pre><pre>  ...</pre><pre>&lt;/vector&gt;</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/324/1*XwETOHbx50_CT4tRbbBdog.png" /><figcaption>The shadow produced by the radial gradient.</figcaption></figure><p>Most icons include some kind of drop-shadow element in them (per the <a href="https://material.io/guidelines/style/icons.html#icons-product-icons">material guidelines</a>) which unfortunatelyVectorDrawable does not support. With adaptive icons, there are two features that make vectors more relevant:</p><ol><li>The launcher is now responsible for masking the overall drawable and providing any drop shadow for the full shape. You no longer have to bake in a shadow for the entire shape.</li><li>The icon is comprised of a background and a foreground image, so if one of those layers does not require any shadows, then it can take advantage of vectors.</li></ol><p>Some simple shadows can be approximated using gradients but unfortunately not everything.</p><h4>Minimum viable raster</h4><p>If you can‚Äôt implement your design with vectors then it‚Äôs perfectly fine to do so using PNGs. Your launcher icon is such a crucial asset that it‚Äôs definitely worth a few extra bytes to make the right impression.</p><p>There is however a neat trick that you can utilize for assets with areas of transparency in them‚Ä¶ which is somewhat common in adaptive icon foregrounds. While this kind of asset likely compresses well at build time, at run time each pixel takes up 8 bits of memory no matter what the opacity. To minimize this, if the transparency is around the edges, you can trim these areas from the PNG and use an <a href="https://developer.android.com/guide/topics/resources/drawable-resource.html#Inset">InsetDrawable</a> to wrap it and fill it out to its 108dp size. Now unfortunately InsetDrawable doesn‚Äôt love being resized (i.e. if you set a top inset of 16dp it will always be 16dp no matter how the drawable‚Äôs bounds are resized) so in API26 <em>fractional</em> insets were added to mitigate this. This lets you specify insets as a percentage of the overall drawable so they will scale correctly.</p><p>For example, say you have a foreground asset which is 54dp*54dp; instead of placing that in a 108dp*108dp asset amidst transparency you can do the following.</p><pre>&lt;inset ...<br>    android:drawable=&quot;@mipmap/<strong>ic_fg_trimmed</strong>&quot;<br>    android:insetLeft=&quot;25%&quot;<br>    android:insetTop=&quot;25%&quot;<br>    android:insetRight=&quot;25%&quot;<br>    android:insetBottom=&quot;25%&quot; /&gt;</pre><p>Here‚Äôs <a href="https://github.com/nickbutcher/AdaptiveIconPlayground/blob/master/app/src/main/res/drawable-xxxhdpi/ic_launcher_alt_foreground.xml">an example</a> using this technique:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*slPwmRAoMkR0aQqdj_PzYg.png" /><figcaption><em>No need to ship/load transparent pixels</em></figcaption></figure><p>Note that you‚Äôll still have to provide the trimmed raster asset at different densities, but at least each will be smaller and in-memory size will be much reduced.</p><h4>Take a shortcut</h4><p>Adaptive icons aren‚Äôt solely for <em>app</em> icons, they‚Äôre also used for <a href="https://developer.android.com/guide/topics/ui/shortcuts.html">app shortcuts</a>. App shortcuts can be pinned to the homescreen so they need to fit in with app icons. The (pre-O) <a href="https://material.io/guidelines/style/icons.html#icons-app-shortcut-icons">design specs</a> call for shortcut icons to sit on a grey circular background. In Android-O, the background should fill the adaptive icon mask. If you don‚Äôt update to adaptive, your shortcut icon will be scaled down and placed on a white background.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/850/1*TADH3ryfMLFjlKzDfkmXxA.png" /><figcaption><em>Plaid‚Äôs search shortcut; before and after becoming adaptive</em></figcaption></figure><p>To implement this in my app <a href="https://github.com/nickbutcher/plaid">Plaid</a>, I initially <a href="https://github.com/nickbutcher/plaid/commit/b7f0ed1">added new icons</a> in the v26 configuration, re-drawn for the adaptive grid and <a href="https://medium.com/google-design/designing-adaptive-icons-515af294c783#aad8">keylines</a>. I wasn‚Äôt happy with this approach as they were essentially scaled versions of the v25 icons; meaning I now had two icons to maintain. <a href="https://github.com/nickbutcher/plaid/commit/2d8d428">Ultimately</a> I decided to break the v25 icon into a foreground (e.g. the search icon) and background (the grey circle) and combine them with a LayerDrawable:</p><pre>&lt;layer-list ...&gt;</pre><pre>  &lt;item android:drawable=&quot;@drawable/<strong>ic_app_shortcut_background</strong>&quot;/&gt;</pre><pre>  &lt;item android:drawable=&quot;@drawable/<strong>ic_shortcut_search_foreground</strong>&quot;/&gt;</pre><pre>&lt;/layer-list&gt;</pre><p>I could then use the same foreground asset in the adaptive icon. On v25, app shortcut icons are 24dp within a 48dp asset; on v26 they‚Äôre 44dp within a 108dp asset:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/545/1*6kLde9OxebWfWOm7pLVCqA.png" /><figcaption><em>App shortcut icon foreground assets required on API 25 &amp; API 26</em></figcaption></figure><p>To use the same 48dp file I needed to inset it so that the icon is the correct size once it‚Äôs scaled up (yay vectors!) to the 108dp adaptive icon size. The background is achieved using a ColorDrawable:</p><pre>&lt;adaptive-icon ...&gt;</pre><pre>  &lt;background android:drawable=&quot;@color/light_grey&quot; /&gt;</pre><pre>  &lt;foreground&gt;</pre><pre>    &lt;!-- 10dp padding on each side of 108dp asset --&gt;<br>    &lt;inset<br>      android:drawable=&quot;@drawable/<strong>ic_shortcut_search_foreground</strong>&quot;<br>      android:inset=&quot;9.26%&quot; /&gt;</pre><pre>  &lt;/foreground&gt;</pre><pre>&lt;/adaptive-icon&gt;</pre><blockquote>AdaptiveIconDrawable will scale the supplied asset to 108dp, so to calculate the inset required to produce a 44dp icon: 48 / 24 * 44 = 88; that is we need to inset the scaled up asset by 10dp each side: 10 / 108 ‚Üí 9.26%</blockquote><p>For bitmap image shortcuts, use <a href="https://developer.android.com/reference/android/graphics/drawable/Icon.html#createWithAdaptiveBitmap(android.graphics.Bitmap)">Icon#createWithAdaptiveBitmap</a>.</p><h4>Play around</h4><p>If you‚Äôre building an adaptive icon, then the Adaptive Icon Playground app might be useful to you. It lets you preview adaptive icons on your device, see how they look with different masks applied and explore some motion effects.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/350/1*REFtTZHdFnu8TAK_Q4-XYA.gif" /></figure><p>You can <a href="https://github.com/nickbutcher/AdaptiveIconPlayground/releases">grab an APK</a> (for devices already running Android-O) or check it out on github:</p><p><a href="https://github.com/nickbutcher/AdaptiveIconPlayground">nickbutcher/AdaptiveIconPlayground</a></p><h4>Adapt away</h4><p>Hopefully these tips will help you to build awesome adaptive icons that will make your app a better resident of your user‚Äôs device. If you‚Äôve got any tips for implementing adaptive icons, then let me know in the comments.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1e4d1795470e" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/implementing-adaptive-icons-1e4d1795470e">Implementing Adaptive Icons</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[7 Steps To Room]]></title>
            <link>https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/27a5fe5f99b2</guid>
            <category><![CDATA[architecture-components]]></category>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[sqlite]]></category>
            <category><![CDATA[android-room]]></category>
            <category><![CDATA[database]]></category>
            <dc:creator><![CDATA[Florina Muntenescu]]></dc:creator>
            <pubDate>Fri, 07 Jul 2017 17:07:26 GMT</pubDate>
            <atom:updated>2017-07-24T15:35:07.411Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MhuoTzXc0jJ7mrTrDTj4xw.jpeg" /><figcaption>Take the 7 steps to Room (<a href="https://unsplash.com/photos/bt-Sc22W-BE">Source</a>)</figcaption></figure><p><em>A step by step guide on how to migrate your app to Room</em></p><p><a href="https://developer.android.com/topic/libraries/architecture/room.html">Room</a> is a persistence library, part of the Android <a href="https://developer.android.com/topic/libraries/architecture/index.html">Architecture Components</a>. It makes it easier to work with SQLiteDatabase objects in your app, decreasing the amount of boilerplate code and verifying SQL queries at compile time.</p><p>Do you already have an Android project that uses SQLite for data persistence? If so, you can migrate it to Room! Let‚Äôs see how by taking a pre-existing project and refactoring it to use Room, in 7 easy steps.</p><blockquote><strong>TL;DR: Update your gradle dependencies, create your entities, DAOs and database, replace your SQLiteDatabase calls with calls to DAO methods, test everything you‚Äôve created or modified and remove unused classes. That‚Äôs it!</strong></blockquote><p>Our <a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample">migration sample app</a> shows an editable user name, stored in the database, as part of a User object. We used product flavors to showcase different implementations of the data layer:</p><ol><li><strong>sqlite</strong>‚Ää‚Äî‚ÄäUses SQLiteOpenHelper and traditional SQLite interfaces.</li><li><strong>room</strong>‚Ää‚Äî‚ÄäReplaces implementation with Room and provides migrations.</li></ol><p>Each flavor uses the same UI layer, applying the Model-View-Presenter design pattern and working with a UserRepository class.</p><p>In the sqlite flavor, you‚Äôll see a lot of code duplicated across every method that queries the database in the UsersDbHelper and LocalUserDataSource classes. The queries are constructed with the help of ContentValues, and the data returned by Cursor objects is read column by column. All this code makes it very easy to introduce subtle bugs such as forgetting to add a column to the query or constructing model objects incorrectly from the database data.</p><p>Let‚Äôs see how Room improves our code. Initially, we just copy the classes from the sqlite flavor and gradually modify them.</p><h3>Step 1‚Ää‚Äî‚ÄäUpdate the gradle dependencies</h3><p>Room‚Äôs dependencies are available via Google‚Äôs new Maven repository, simply add it to the list of repositories in your main build.gradle file:</p><pre>allprojects {<br>    repositories {<br>        google()<br>        jcenter()<br>    }<br>}</pre><p>Define your Room library version in the same file. For now, it‚Äôs in alpha, but keep an eye on our <a href="https://developer.android.com/topic/libraries/architecture/release-notes.html">developer pages</a> for version updates.</p><pre>ext {<br>   ... <br>    roomVersion = &#39;1.0.0-alpha4&#39;<br>}</pre><p>In your app/build.gradle file, add the dependencies for Room.</p><pre>dependencies{<br> ‚Ä¶</pre><pre>implementation        <br>   ‚Äúandroid.arch.persistence.room:runtime:$rootProject.roomVersion‚Äù</pre><pre>annotationProcessor <br>   ‚Äúandroid.arch.persistence.room:compiler:$rootProject.roomVersion‚Äù</pre><pre>androidTestImplementation <br>   ‚Äúandroid.arch.persistence.room:testing:$rootProject.roomVersion‚Äù</pre><pre>}</pre><p>To migrate to Room we will need to increase the database version and, in order to preserve user data, we will need to implement a <a href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html">Migration</a> class. To <a href="https://developer.android.com/topic/libraries/architecture/room.html#db-migration">test the migration</a>, we need to export the schema. For that, add the following to your app/build.gradle file:</p><pre>android {<br>    defaultConfig {<br>        ...<br>       // used by Room, to test migrations<br>        javaCompileOptions {<br>            annotationProcessorOptions {<br>                arguments = [&quot;room.schemaLocation&quot;: <br>                                 &quot;$projectDir/schemas&quot;.toString()]<br>            }<br>        }<br>    }<br><br>    // used by Room, to test migrations<br>    sourceSets {<br>        androidTest.assets.srcDirs += <br>                           files(&quot;$projectDir/schemas&quot;.toString())<br>    }<br>...</pre><h3>Step 2‚Ää‚Äî‚ÄäUpdate model classes to entities</h3><p>Room creates a table for each class annotated with <a href="https://developer.android.com/reference/android/arch/persistence/room/Entity.html">@Entity</a>; the fields in the class correspond to columns in the table. Therefore, the entity classes tend to be small model classes that don‚Äôt contain any logic. Our User class represents the model for the data in the database. So let‚Äôs update it to tell Room that it should create a table based on this class:</p><ul><li>Annotate the class with @Entity and use the tableName property to set the name of the table.</li><li>Set the primary key by adding the @PrimaryKey annotation to the correct fields‚Ää‚Äî‚Ääin our case, this is the ID of the User.</li><li>Set the name of the columns for the class fields using the @ColumnInfo(name = ‚Äúcolumn_name‚Äù) annotation. Feel free to skip this step if your fields already have the correct column name.</li><li>If multiple constructors are suitable, add the @Ignore annotation to tell Room which should be used and which not.</li></ul><pre>@Entity(tableName = &quot;users&quot;)<br>public class User {<br><br>    @PrimaryKey<br>    @ColumnInfo(name = &quot;userid&quot;)<br>    private String mId;<br><br>    @ColumnInfo(name = &quot;username&quot;)<br>    private String mUserName;<br><br>    @ColumnInfo(name = &quot;last_update&quot;)<br>    private Date mDate;<br><br>    @Ignore<br>    public User(String userName) {<br>        mId = UUID.<em>randomUUID</em>().toString();<br>        mUserName = userName;<br>        mDate = new Date(System.<em>currentTimeMillis</em>());<br>    }<br><br>    public User(String id, String userName, Date date) {<br>        this.mId = id;<br>        this.mUserName = userName;<br>        this.mDate = date;<br>    }<br>...<br>}</pre><p><strong>Note:</strong> For a seamless migration, pay close attention to the tables and columns names in your initial implementation and make sure you‚Äôre correctly setting them in the @Entity and @ColumnInfo annotations.</p><h3>Step 3‚Ää‚Äî‚ÄäCreate Data Access Objects (DAOs)</h3><p><a href="https://developer.android.com/topic/libraries/architecture/room.html#daos">DAOs</a> are responsible for defining the methods that access the database. In the initial SQLite implementation of our project, all the queries to the database were done in the LocalUserDataSource file, where we were working with Cursor objects. With Room, we don‚Äôt need all the Cursor related code and can simply define our queries using annotations in the UserDao class.</p><p>For example, when querying the database for all users, Room does all the ‚Äúheavy lifting‚Äù and we only need to write:</p><pre>@Query(‚ÄúSELECT * FROM Users‚Äù)<br>List&lt;User&gt; getUsers();</pre><h3>Step 4‚Ää‚Äî‚ÄäCreate the database</h3><p>So far, we have defined our Users table and its corresponding queries, but we haven‚Äôt yet created the database that brings these other pieces of Room together. To do this, we need to define an abstract class that extends RoomDatabase. This class is annotated with @Database, lists the entities contained in the database, and the DAOs which access them. The database version has to be increased by 1, from the initial value, so in our case, it will be 2.</p><pre>@Database(entities = {User.class}, version = 4)<br>@TypeConverters(DateConverter.class)<br>public abstract class UsersDatabase extends RoomDatabase {<br><br>    private static UsersDatabase <em>INSTANCE</em>;<br><br>    public abstract UserDao userDao();</pre><p>Because we want to keep the user data, we need to implement a <a href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html">Migration</a> class, telling Room what it should do when migrating from version 1 to 2. In our case, because the database schema isn‚Äôt altered, we will just provide an empty implementation:</p><pre>static final Migration <em>MIGRATION_1_2 </em>= new Migration(1, 2) {<br>    @Override<br>    public void migrate(SupportSQLiteDatabase database) {<br>// Since we didn&#39;t alter the table, there&#39;s nothing else to do here.<br>    }<br>};</pre><p>Create the database object in the UsersDatabase class, defining the database name and the migration:</p><pre>database = Room.<em>databaseBuilder</em>(context.getApplicationContext(),<br>        UsersDatabase.class, &quot;Sample.db&quot;)<br>        .addMigrations(<em>MIGRATION_1_2</em>)<br>        .build();</pre><p>To find out more about how to implement database migrations and how they work under the hood, check out this post:</p><p><a href="https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929">Understanding migrations with Room</a></p><h3>Step 5‚Ää‚Äî‚ÄäUpdate the Repository to use Room</h3><p>We‚Äôve created our database, our Users table, and the queries, so now it‚Äôs time to use them! During this step, we‚Äôll update the LocalUserDataSource class to use the UserDao methods. To do this, we‚Äôll first update the constructor by removing the Context and adding UserDao. Of course, any class that instantiates LocalUserDataSource needs to be updated, too.</p><p>Second, we‚Äôll update the LocalUserDataSource methods that query the database with calls to UserDao methods. For example, the method that fetches all users now looks like this:</p><pre>public List&lt;User&gt; getUsers() {<br>   return mUserDao.getUsers();<br>}</pre><p>And now: run time!</p><p>One of the best features of Room is that if you‚Äôre executing your database operations on the main thread, your app will crash, and the following exception message is shown:</p><pre>java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.</pre><p>One reliable way to move I/O operations off the main thread, is to create a new Runnable that runs on a single thread Executor for every database query. As we‚Äôre already using this approach in the sqlite flavor, no changes were needed.</p><h3>Step 6‚Ää‚Äî‚ÄäOn-device testing</h3><p>We‚Äôve created new classes‚Ää‚Äî‚ÄäUserDao and UsersDatabase, and have modified our LocalUserDataSource to use the Room database. Now, we need to test them!</p><h4><strong>Testing </strong><strong>UserDao</strong></h4><p>To test the UserDao, we need to create an AndroidJUnit4 test class. An awesome feature of Room is it‚Äôs ability to create an in-memory database. This avoids the need to clean up after every test case.</p><pre>@Before<br>public void initDb() throws Exception {<br>    mDatabase = Room.inMemoryDatabaseBuilder(<br>                           InstrumentationRegistry.getContext(),<br>                           UsersDatabase.class)<br>                    .build();<br>}</pre><p>We also need to make sure we‚Äôre closing the database connection after each test.</p><pre>@After<br>public void closeDb() throws Exception {<br>    mDatabase.close();<br>}</pre><p>To test the insertion of a User, for example, we will insert the user and then we will check that we can indeed get that User from the database.</p><pre>@Test<br>public void insertAndGetUser() {<br>    // When inserting a new user in the data source<br>    mDatabase.userDao().insertUser(<em>USER</em>);<br><br>    //The user can be retrieved<br>    List&lt;User&gt; users = mDatabase.userDao().getUsers();<br>    <em>assertThat</em>(users.size(), <em>is</em>(1));<br>    User dbUser = users.get(0);<br>    <em>assertEquals</em>(dbUser.getId(), <em>USER</em>.getId());<br>    <em>assertEquals</em>(dbUser.getUserName(), <em>USER</em>.getUserName());<br>}</pre><h4><strong>Testing the </strong><strong>UserDao usage in LocalUserDataSource</strong></h4><p>Making sure that LocalUserDataSource still works correctly is easy, since we already have tests that cover the behavior of this class. All we need to do is create an in-memory database, acquire a UserDao object from it, and use it as a parameter for the LocalUserDataSource constructor.</p><pre>@Before<br>public void initDb() throws Exception {<br>    mDatabase = Room.inMemoryDatabaseBuilder(<br>                           InstrumentationRegistry.getContext(),<br>                           UsersDatabase.class)<br>                    .build();<br>    mDataSource = new LocalUserDataSource(mDatabase.userDao());<br>}</pre><p>Again, we need to make sure that we close the database after every test.</p><h4><strong>Testing the database migration</strong></h4><p>We discussed in detail how to implement database migration tests together with an explanation of how the MigrationTestHelper works in this blog post:</p><p><a href="https://medium.com/google-developers/testing-room-migrations-be93cdb0d975">Testing Room migrations</a></p><p>Check out the code from the <a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample">migration sample app</a> for a more extensive example.</p><h3>Step 7‚Ää‚Äî‚ÄäCleanup</h3><p>Remove any unused classes or lines of code that are now replaced by Room functionality. In our project, we just had to delete the UsersDbHelper class, that was extending the SQLiteOpenHelper class.</p><p>The amount of boilerplate, error-prone code decreased, the queries are now checked at compile time and everything is testable. In 7 easy steps we were able to migrate our existing app to Room. Check out sample app <a href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample">here</a>. Let us know how your migration to Room went in the comments below.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=27a5fe5f99b2" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2">7 Steps To Room</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ViewModels : A Simple Example]]></title>
            <link>https://medium.com/google-developers/viewmodels-a-simple-example-ed5ac416317e?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/ed5ac416317e</guid>
            <category><![CDATA[android-app-development]]></category>
            <category><![CDATA[architecture-components]]></category>
            <category><![CDATA[application-lifecycle]]></category>
            <dc:creator><![CDATA[Lyla Fujiwara]]></dc:creator>
            <pubDate>Wed, 28 Jun 2017 00:24:10 GMT</pubDate>
            <atom:updated>2017-07-07T06:47:25.796Z</atom:updated>
            <content:encoded><![CDATA[<h3>Introduction</h3><p>A little over two years ago, I was working on <a href="https://www.udacity.com/course/android-development-for-beginners--ud837">Android for Beginners</a>; a class that takes students from zero programming to their first Android app. As part of the course, students build a very simple one screen app called <a href="https://github.com/udacity/Court-Counter">Court-Counter</a>.</p><p>Court-Counter is a <em>very </em>straightforward app with buttons that modify a basketball score. The finished app has a bug though; if you rotate the phone, your current score will inexplicably disappear.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/710/1*kZ5CiWnpSC0-aQeModzpNA.gif" /></figure><p>What‚Äôs going on? Rotating a device is one of a few <a href="https://developer.android.com/guide/topics/manifest/activity-element.html#config"><strong>configuration changes</strong></a> that an app can go through during its lifetime, including keyboard availability and changing the device‚Äôs language. All of these configuration changes cause the Activity to be torn down and recreated.</p><p>This behavior allows us to do things like use a landscape orientation specific layout when the device is rotated on its‚Äô side. Unfortunately it can be a headache for new (and sometimes not so new) engineers to wrap their head around.</p><p>At Google I/O 2017, the Android Framework team introduced a new set of <a href="https://developer.android.com/topic/libraries/architecture/index.html">Architecture Components</a>, one of which deals with this exact rotation issue.</p><p>The <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html"><strong>ViewModel</strong></a> class is designed to hold and manage UI-related data in a life-cycle conscious way. This allows data to survive configuration changes such as screen rotations.</p><p>This post is the first in a series exploring the ins and outs of ViewModel. In this post I‚Äôll:</p><ul><li>Explain the basic need ViewModels fulfill</li><li>Solve the rotation issue by changing the Court-Counter code to use a ViewModel</li><li>Take a closer look at ViewModel and UI Component association</li></ul><h3>The underlying problem</h3><p>The underlying challenge is that the <a href="https://developer.android.com/guide/components/activities/activity-lifecycle.html">Android Activity lifecycle</a> has a lot of states and a single Activity might cycle through these different states many times due to configuration changes.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/513/1*CGGROXWhl8dTko1GdDeFsA.png" /></figure><p>As an Activity is going through all of these states, you also might have transient UI data that you need to keep in memory. I‚Äôm going to define <strong>transient UI data</strong> as data needed for the UI. Examples include data the user enters, data generated during runtime, or data loaded from a database. This data could be bitmap images, a list of objects needed for a RecyclerView or, in this case, a basketball score.</p><p>Previously, you might have used <a href="https://developer.android.com/reference/android/app/Activity.html#onRetainNonConfigurationInstance()">onRetainNonConfigurationInstance</a> to save this data during a configuration change and unpack it on the other end. But wouldn‚Äôt it be swell if your data didn‚Äôt need to know or manage what lifecycle state the Activity is in? Instead of having a variable like scoreTeamA within the Activity, and therefore tied to all the whims of the Activity lifecycle, what if that data was stored somewhere else, outside of the Activity? <strong>This is the purpose of the ViewModel class.</strong></p><p>In the diagram below, you can see the lifecycle of an Activity which undergoes a rotation and then is finally finished. The lifetime of the ViewModel is shown next to the associated Activity lifecycle. Note that ViewModels can be easily used with both Fragments and Activities, which I‚Äôll call <strong>UI controllers</strong>. This example focuses on Activities.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/522/1*3Kr2-5HE0TLZ4eqq8UQCkQ.png" /></figure><p>The ViewModel exists from when the you first request a ViewModel (usually in the onCreate the Activity) until the Activity is finished and destroyed. onCreate may be called several times during the life of an Activity, such as when the app is rotated, but the ViewModel survives throughout.</p><h3>A very simple example</h3><p>There are three steps to setting up and using a ViewModel:</p><ol><li>Separate out your data from your UI controller by creating a class that extends <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html">ViewModel</a></li><li>Set up communications between your ViewModel and your UI controller</li><li>Use your ViewModel in your UI controller</li></ol><h4>Step 1: Create a ViewModel class</h4><p>In general, you‚Äôll make a ViewModel class for each screen in your app. This ViewModel class will hold all of the data associated with the screen and have getters and setters for the stored data. This separates the code to display the UI, which is implemented in your Activities and Fragments, from your data, which now lives in the ViewModel. So, let‚Äôs create a ViewModel class for the one screen in Court-Counter:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3bf0eb67d3ea768ffd8639e1ec47a1c3/href">https://medium.com/media/3bf0eb67d3ea768ffd8639e1ec47a1c3/href</a></iframe><p>I‚Äôve chosen to have the data stored as public members in my ScoreViewModel.java for brevity, but creating getters and setters to better encapsulate the data is a good idea.</p><h4>Step 2: Associate the UI Controller and ViewModel</h4><p>Your UI controller (aka Activity or Fragment) needs to know about your ViewModel. This is so your UI controller can display the data and update the data when UI interactions occur, such as pressing a button to increase a team‚Äôs score in Court-Counter.</p><p><strong>ViewModels should not, though, hold a reference to Activities, Fragments, or </strong><a href="https://developer.android.com/reference/android/content/Context.html"><strong>Context</strong></a><strong>s</strong>.<strong>**</strong> Furthermore, ViewModels should not contain elements that contain references to UI controllers, such as Views, since this will create an indirect reference to a Context.</p><p>The reason you shouldn‚Äôt store these objects is that ViewModels outlive your specific UI controller instances‚Ää‚Äî‚Ääif you rotate an Activity three times, you have just created three different Activity instances, but you only have one ViewModel.</p><p>With that in mind, let‚Äôs create this UI controller/ViewModel association. You‚Äôll want to create a member variable for your ViewModel in the UI Controller. Then in onCreate, you should call:</p><pre>ViewModelProviders.of(<strong>&lt;Your UI controller&gt;</strong>).get(<strong>&lt;Your ViewModel&gt;.class</strong>)</pre><p>In the case of Court-Counter, this looks like:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/98ae516d5db75c4dc3f8b01d39c1419d/href">https://medium.com/media/98ae516d5db75c4dc3f8b01d39c1419d/href</a></iframe><p><strong>**Note: </strong>There‚Äôs one exception to the ‚Äúno contexts in ViewModels‚Äù rule. Sometimes you might need an <a href="https://developer.android.com/reference/android/content/Context.html#getApplicationContext()"><strong>Application context</strong></a><strong> </strong>(as opposed to an Activity context) for use with things like system services. Storing an Application context in a ViewModel is okay because an Application context is tied to the Application lifecycle. This is different from an Activity context, which is tied to the Activity lifecycle. In fact, if you need an Application context, you should extend <a href="https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel.html"><strong>AndroidViewModel</strong></a> which is simply a ViewModel that includes an Application reference.</p><h4>Step 3: Use the ViewModel in your UI Controller</h4><p>To access or change UI data, you can now use the data in your ViewModel. Here‚Äôs an example of the new onCreate method and a method for updating the score by adding one point to team A:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6f1377d09db1054b7903205e432434d2/href">https://medium.com/media/6f1377d09db1054b7903205e432434d2/href</a></iframe><p><strong>Pro tip:</strong> ViewModel also works very nicely with another Architecture Component, <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html">LiveData</a>, which I won‚Äôt be exploring deeply in this series. The added bonus here of using LiveData is that it‚Äôs observable: it can trigger UI updates when the data changes. You can learn more about LiveData <a href="https://developer.android.com/topic/libraries/architecture/livedata.html">here</a>.</p><h3>A closer look at ViewModelsProviders.of</h3><p>The first time the <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html#of(android.support.v4.app.Fragment)">ViewModelProviders.of</a> method is called by MainActivity, it creates a new ViewModel instance. When this method is called again, which happens whenever onCreate is called, it will return the pre-existing ViewModel associated with the specific Court-Counter MainActivity. This is what preserves the data.</p><p>This works only if you pass in the correct UI controller as the first argument. While you should <strong>never</strong> store a UI controller inside of a ViewModel, the ViewModel class does keep track of the associations between ViewModel and UI controller instance behind the scenes, using the UI controller you pass in as the first argument.</p><pre>ViewModelProviders.<em>of</em>(<strong>&lt;THIS ARGUMENT&gt;</strong>).get(ScoreViewModel.<strong>class</strong>);</pre><p>This allows you to have an app that opens a lot of different instances of the same Activity or Fragment, but with different ViewModel information. Let‚Äôs imagine if we extended our Court-Counter example to have the scores for multiple basketball games. The games are presented in a list, and then clicking on a game in the list opens a screen that looks like our current MainActivity, but which I‚Äôll call GameScoreActivity.</p><p>For every different game screen you open, if you associate the ViewModel and GameScoreActivity in onCreate, it will create a different ViewModel instance. If you rotate one of these screens, the connection to the <strong>same</strong> ViewModel is maintained.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uQ6XDm4Ga14SJWlCb27rkg.png" /></figure><p>All of this logic is done for you by calling ViewModelProviders.of(&lt;Your UI controller&gt;).get(&lt;Your ViewModel&gt;.class). So as long as you pass in the correct instance of a UI controller, it just works.</p><p><strong>A final thought</strong>: ViewModels are very nifty for separating out your UI controller code from the data which fills your UI. That said, they are not a cure all for data persistence and saving app state. In the next post I‚Äôll explore the subtler interactions of the Activity lifecycle with ViewModels and how ViewModels compare to onSaveInstanceState.</p><h3>Conclusion and further learning</h3><p>In this post, I explored the very basics of the new ViewModel class. The key takeaways are:</p><ul><li>The <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html">ViewModel</a> class is designed to hold and manage UI-related data in a life-cycle conscious way. This allows data to survive configuration changes such as screen rotations.</li><li>ViewModels separate UI implementation from your app‚Äôs data.</li><li>In general, if a screen in your app has transient data, you should create a separate ViewModel for that screen‚Äôs data.</li><li>The lifecycle of a ViewModel extends from when the associated UI controller is first created, till it is completely destroyed.</li><li>Never store a UI controller or Context directly or indirectly in a ViewModel. This includes storing a View in a ViewModel. Direct or indirect references to UI controllers defeat the purpose of separating the UI from the data and can lead to memory leaks.</li><li>ViewModel objects will often store LiveData objects, which you can learn more about <a href="https://developer.android.com/topic/libraries/architecture/livedata.html">here</a>.</li><li>The <a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelProviders.html#of(android.support.v4.app.Fragment)">ViewModelProviders.of</a> method keeps track of what UI controller the ViewModel is associated with via the UI controller that is passed in as an argument.</li></ul><p>Want more ViewModel-ly goodness? Check out:</p><ul><li><a href="https://developer.android.com/topic/libraries/architecture/adding-components.html">Instructions for adding the gradle dependencies</a></li><li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html">ViewModel</a> documentation</li><li>Guided ViewModel practice with the <a href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#0">Lifecycles Codelab</a></li></ul><p>The Architecture Components were created based upon your feedback. If you have questions or comments about ViewModel or any of the architecture components, check out our <a href="https://developer.android.com/topic/libraries/architecture/feedback.html">feedback page</a>. Questions about or suggestion for this series? Leave a comment!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ed5ac416317e" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/viewmodels-a-simple-example-ed5ac416317e">ViewModels : A Simple Example</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Lessons learned while converting to Kotlin with Android Studio]]></title>
            <link>https://medium.com/google-developers/lessons-learned-while-converting-to-kotlin-with-android-studio-f0a3cb41669?source=rss----2e5ce7f173a5---4</link>
            <guid isPermaLink="false">https://medium.com/p/f0a3cb41669</guid>
            <category><![CDATA[androiddev]]></category>
            <category><![CDATA[android]]></category>
            <category><![CDATA[kotlin]]></category>
            <category><![CDATA[android-studio]]></category>
            <dc:creator><![CDATA[Benjamin Baxter]]></dc:creator>
            <pubDate>Wed, 21 Jun 2017 20:52:31 GMT</pubDate>
            <atom:updated>2017-06-29T19:57:55.577Z</atom:updated>
            <content:encoded><![CDATA[<h4><strong>Advancing your Kotlin conversion with Android Studio</strong></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9Dt8JaHzWXJGID-NTVIuPw.png" /></figure><p>I was excited to finally try the popular language Kotlin while converting a simple app from Java using the <a href="https://developer.android.com/kotlin/get-started.html#convert-to-kotlin-code">Convert Java File to Kotlin</a> tool in Android Studio. I gave it try, and this is my story of converting this project.</p><p>I quickly found out that the tool in Android Studio converts a majority of my Java classes perfectly. There were a few places that needed to be cleaned up and I learned a few new keywords from the conversion!</p><p>I will share these insights with you:</p><ul><li><strong><em>long</em></strong>s became <strong><em>int</em></strong>s</li><li><em>lateinit</em> keyword</li><li><em>internal</em> keyword</li><li>Companion Object</li><li>Cleaning up ranges</li><li>Lazy loading</li><li>Destructuring</li></ul><p>Before we get started, if you ever question what actually happens underneath the covers in your Kotlin code, you can examine it in Android Studio by going to <strong><em>Tools ‚Üí Kotlin ‚Üí Show Kotlin Bytecode</em></strong>.</p><h4>Longing for longs</h4><p>I almost missed the first change because it was so small. The converter magically changed a <strong><em>long</em></strong> constant in one of my classes to an <strong><em>int</em></strong> and cast it back to a <strong><em>long</em></strong> every time it was used. Yikes!</p><pre><strong>companion object </strong>{<br>    <strong>private val TIMER_DELAY </strong>= 3000<br>}</pre><pre>//...</pre><pre>handler.postDelayed(<strong>{<br>    //...<br>}</strong>, <strong>TIMER_DELAY</strong>.toLong())</pre><p>The good news? It recognized the constant by using the <strong><em>val</em></strong> keyword.</p><p>The bad news? There was unnecessary casting throughout my activity where I was expecting Kotlin‚Äôs type safety to be more advanced than it is.</p><p>I thought Kotlin‚Äôs type safety was smarter than this. Maybe the converter isn‚Äôt smart enough yet?</p><p>Fixing this was simple; I just needed to add an ‚ÄúL‚Äù to the end of the variable declaration (similar to Java).</p><pre><strong>companion object </strong>{<br>    <strong>private val TIMER_DELAY </strong>= 3000L<br>}</pre><pre>//...</pre><pre>handler.postDelayed(<strong>{<br>    //...<br>}</strong>, <strong>TIMER_DELAY</strong>)</pre><h4>Better Late than Never</h4><p>One of Kotlin‚Äôs biggest features, <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>, aims to eliminate the danger of null references. This is done by a type system that distinguishes between references that can hold null (nullable references) and those that can not (non-null references).</p><p>Most the time you want your references to be non-null, so you don‚Äôt run into NPE (Null Pointer Exceptions).</p><p>However, in some cases, a null reference can be helpful, for example, initializing variables from an onClick() event such as an AsyncTask. There are several ways you can deal with null references:</p><ol><li>Good old <em>if</em> statements checking for null reference before accessing a property (you should be used to those from writing Java).</li><li>A cool <a href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls">Safe Call Operator</a> (syntax <em>?.</em>) which performs a null check in the background for you. If the object is a null reference, it returns a null (not a null pointer exception). No more of those pesky <em>if</em> statements.</li><li>Force the return of a <em>NullPointerException</em> using the the <strong><em>!!</em></strong> operator. So you are basically writing familiar Java code and need to do step 1.</li></ol><p>Knowing exactly which pattern to enforce null-safety is not trivial, so the converter defaults to the simplest solution (option 3) and lets the developer handle the null-safety the best way for their use case.</p><p>I realized letting my Kotlin code throw a null pointer exception is counter-intuitive to the benefits of the language, so I delved deeper to see if there was something even better than what I had already found.</p><p>I discovered the powerful keyword <strong><em>lateinit</em></strong>. Using <strong><em>lateinit</em></strong>, Kotlin allows you to <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties">initialize non-null properties</a> after the constructor has been called, so I am moving away from null properties all together.</p><p>That means I get the benefits of option 2 above (<em>?.</em> syntax) without having to write the extra ‚Äú?.‚Äù. I just handle methods as if they are never null with no boilerplate checks and the same syntax I am used to using.</p><p>Using <strong><em>lateinit</em></strong> is an easy way to remove the <strong><em>!! </em></strong>operators from your Kotlin code. For more tips on how to remove the <strong><em>!!</em></strong> operator and cleanup your code, check out <a href="https://android.jlelse.eu/how-to-remove-all-from-your-kotlin-code-87dc2c9767fb?gi=26743d7b8c09">David V√°vra‚Äôs post</a>.</p><h4>The Internals of internal</h4><p>Since I was converting one class at a time, I was interested in how the converted Kotlin classes would work with remaining Java classes.</p><p>I read Kotlin has complete <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">Java interoperability</a>, so I would expect it to work with no visible change.</p><p>There was a public method within a fragment that converted into an <a href="https://kotlinlang.org/docs/reference/visibility-modifiers.html"><strong><em>internal</em></strong></a> function in Kotlin. In Java, that method didn‚Äôt have any <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">access modifiers</a>, so it was package private.</p><pre><strong>public class </strong>ErrorFragment extends Fragment {<br>    void setErrorContent() <strong>{<br>        //...<br>    }<br></strong>}</pre><p>The converter recognized there were no access modifiers and thought it only should be visible within the module/package by applying the <strong><em>internal</em></strong> keyword for <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#visibility">access visibility</a>.</p><pre><strong>class </strong>ErrorFragment : Fragment() {<br>    <strong>internal fun </strong>setErrorContent() {<br>        <em>//...</em><br>    <strong>}<br></strong>}</pre><p>What does this new keyword mean? Looking into the decompiled bytecode, we quickly see that the method name changes from <em>setErrorContent()</em> to <em>setErrorContent$production_sources_for_module_app()</em>.</p><pre><strong>public final void </strong>setErrorContent$production_sources_for_module_app() {<br>   <strong>//...</strong><br>}</pre><p>The good news is that in other Kotlin classes, we only need to know the original method name.</p><pre><strong>mErrorFragment</strong>.setErrorContent()</pre><p>Kotlin will translate to the generated name under the covers for us. Looking again at the decompiled code we see the translation.</p><pre>// Accesses the ErrorFragment instance and invokes the actual method<br>ErrorActivity.<em>access$getMErrorFragment$p</em>(ErrorActivity.<strong>this</strong>)<br>    .setErrorContent$production_sources_for_module_app();</pre><p>The change in method name is handled by Kotlin for us but what about other Java classes?</p><p>From a Java class, you can‚Äôt call <em>errorFragment.setErrorContent()</em>, since that ‚Äúinternal‚Äù method does not really exist (method name has changed).</p><p>The <em>setErrorContent()</em> method is no longer visible to Java classes as we can see from the api in the intellisense box from Android Studio, so you have to use the generated (clunky) method name.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*WwibbTRArE2IE93n." /></figure><p>Even though Kotlin and Java work well together, there can be some unexpected behavior around the <em>internal</em> keyword when calling Kotlin classes from a Java class.</p><p>If you plan to migrate to Kotlin in phases, just keep that in mind.</p><h4>Companion Can Complicate</h4><p>Kotlin does not allow <a href="https://kotlinlang.org/docs/reference/classes.html#companion-objects">public static variables/methods</a> that we are typically used to in Java. Instead it has the concept of a <a href="https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects">companion object</a> that handles the behavior of statics and interfaces in Java.</p><p>If you create a constant in a <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#static-fields">Java class</a> and convert it to Kotlin, the converter does not realize the <strong><em>static final</em></strong> variable was intended to be used as a constant which can lead to weird interoperability between Kotlin and Java.</p><p>When you want a constant in Java, you create a static final variable:</p><pre><strong>public class </strong>DetailsActivity <strong>extends </strong>Activity {<br>    <strong>public static final </strong>String <strong><em>SHARED_ELEMENT_NAME </em></strong>= <strong>&quot;hero&quot;</strong>;<br>    <strong>public static final </strong>String <strong><em>MOVIE </em></strong>= <strong>&quot;Movie&quot;</strong>;<br><br>    <em>//...</em><br><br>}</pre><p>After the conversion, you will see that they end up in a companion class.</p><pre><strong>class </strong>DetailsActivity : Activity() {<br><br>    <strong>companion object </strong>{<br>        <strong>val SHARED_ELEMENT_NAME </strong>= <strong>&quot;hero&quot;<br>        val MOVIE </strong>= <strong>&quot;Movie&quot;<br>    </strong>}<br><br>    <strong>//...</strong><br>}</pre><p>This works as you would expect when used by other Kotlin classes.</p><pre><strong>val </strong>intent = Intent(<em>context</em>, DetailsActivity::<strong>class</strong>.<em>java</em>)<br>intent.putExtra(DetailsActivity.<strong>MOVIE</strong>, item)</pre><p>However, because Kotlin converts the constant into its own companion class, access to your constants <strong>from a Java class</strong> is not intuitive.</p><pre>intent.putExtra(DetailsActivity.<strong>Companion.getMOVIE()</strong>, item)</pre><p>When we decompile the Kotlin class, we see that our constants become private and are exposed via a companion wrapper class.</p><pre><strong>public final class </strong>DetailsActivity <strong>extends </strong>Activity {<br>   @NotNull<br>   <strong>private static final </strong>String <strong><em>SHARED_ELEMENT_NAME </em></strong>= <strong>&quot;hero&quot;</strong>;<br>   @NotNull<br>   <strong>private static final </strong>String <strong><em>MOVIE </em></strong>= <strong>&quot;Movie&quot;</strong>;<br>   <strong>public static final </strong>DetailsActivity.Companion <strong><em>Companion </em></strong>= <strong>new </strong>DetailsActivity.Companion((DefaultConstructorMarker)<strong>null</strong>);</pre><pre>   <strong>//...</strong><br><br>   <strong>public static final class </strong>Companion {<br>      @NotNull<br>      <strong>public final </strong>String getSHARED_ELEMENT_NAME() {<br>         <strong>return </strong>DetailsActivity.<strong><em>SHARED_ELEMENT_NAME</em></strong>;<br>      }<br><br>      @NotNull<br>      <strong>public final </strong>String getMOVIE() {<br>         <strong>return </strong>DetailsActivity.<strong><em>MOVIE</em></strong>;<br>      }<br><br>      <strong>private </strong>Companion() {<br>      }<br><br>      <em>// $FF: synthetic method<br>      </em><strong>public </strong>Companion(DefaultConstructorMarker $constructor_marker) {<br>         <strong>this</strong>();<br>      }<br>   }<br>}</pre><p>This makes our Java code more complex than it needs to be.</p><p>The good news is that we can fix some of these issues, and get the behavior we want, by using the <a href="https://kotlinlang.org/docs/reference/properties.html#compile-time-constants"><strong><em>const</em></strong></a> keyword in the companion class.</p><pre><strong>class </strong>DetailsActivity : Activity() {<br><br>    <strong>companion object </strong>{<br>        <strong>const val SHARED_ELEMENT_NAME </strong>= <strong>&quot;hero&quot;<br>        const val MOVIE </strong>= <strong>&quot;Movie&quot;<br>    </strong>}<br><br>    <strong>//...</strong><br>}</pre><p>Now when we look at the decompiled code, we see our constants!</p><p>Sadly, we still end up creating an empty companion class instance. üòî</p><pre><strong>public final class </strong>DetailsActivity <strong>extends </strong>Activity {<br>   @NotNull<br>   <strong>public static final </strong>String <strong><em>SHARED_ELEMENT_NAME </em></strong>= <strong>&quot;hero&quot;</strong>;<br>   @NotNull<br>   <strong>public static final </strong>String <strong><em>MOVIE </em></strong>= <strong>&quot;Movie&quot;</strong>;<br>   <strong>public static final </strong>DetailsActivity.Companion <strong><em>Companion </em></strong>= <strong>new </strong>DetailsActivity.Companion((DefaultConstructorMarker)<strong>null</strong>);</pre><pre>   //...</pre><pre>   <strong>public static final class </strong>Companion {<br>      <strong>private </strong>Companion() {<br>      }<br><br>      <em>// $FF: synthetic method<br>      </em><strong>public </strong>Companion(DefaultConstructorMarker $constructor_marker) {<br>         <strong>this</strong>();<br>      }<br>   }<br>}</pre><p>We can now access our constants as expected in our Java classes!</p><pre>intent.putExtra(DetailsActivity.<strong>MOVIE</strong>, item)</pre><p>Note that this only applies to <a href="https://kotlinlang.org/docs/reference/properties.html#compile-time-constants">primitives and Strings</a>. For more information on non-primitives, check out <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#instance-fields">@JvmField</a> and <a href="https://medium.com/@BladeCoder/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62">Kotlin‚Äôs hidden costs</a>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*1t1Yypjigwopex-E." /></figure><h4><strong>Looping was limited <em>until</em> Kotlin improved it</strong></h4><p>By default, Kotlin converts loops over ranges using 0..N-1 bounds, which can be hard to maintain since there‚Äôs a potential of introducing <a href="https://en.wikipedia.org/wiki/Off-by-one_error">off-by-one error</a>.</p><p>For example, in my code, there was a nested <em>for</em> loop that added cards for each row/column in a grid; pretty typical Android <em>for</em> looping.</p><pre><strong>for </strong>(<strong>int</strong> i = 0; i &lt; <strong>NUM_ROWS</strong>; i++) {<br>    //...<br>    <strong>for </strong>(<strong>int</strong> j = 0; j &lt; <strong>NUM_COLS</strong>; j++) {<br>        //...<br>    }<br>    //...<br>}</pre><p>The conversion was pretty straightforward.</p><pre><strong>for </strong>(i <strong>in</strong> 0..<strong>NUM_ROWS</strong> - 1) {<br>    //...<br>    <strong>for </strong>(j <strong>in</strong> 0..<strong>NUM_COLS</strong> - 1) {<br>        //...<br>    }<br>    //...<br>}</pre><p>When converted, the code can look unfamiliar for Java developers, almost like it was written in Ruby or Python.</p><p>After reading Dan Lew‚Äôs<a href="http://blog.danlew.net/2017/06/05/musings-on-kotlin-ranges/"> blog</a>, it appeared Kotlin‚Äôs range function is inclusive by default. However, when I read about Kotlin‚Äôs<a href="https://kotlinlang.org/docs/reference/ranges.html"> range features</a>, I saw that their range features are extremely advanced and flexible.</p><p>We can simplify the converted code and make it more readable by leveraging some of Kotlin‚Äôs cool features.</p><pre><strong>for </strong>(i <strong>in </strong>0 <em>until </em><strong>NUM_ROWS</strong>) {<br>    //...<br>    <strong>for </strong>(j <strong>in </strong>0 <em>until </em><strong>NUM_COLS</strong>) {<br>        //...<br>    }<br>    //...<br>}</pre><p>The <em>until</em> function makes our loops exclusive and easier to read. No more wondering about that awkward minus one!</p><h3>Helpful tips for advanced Kotlin-ing</h3><h4>Feeling Kinda Lazy</h4><p>Sometimes it is beneficial to lazy-load a member variable. Imagine you have a singleton class that manages a list of data. You do not need to create the list each time, so we often find ourselves making a<a href="https://en.wikipedia.org/wiki/Lazy_initialization#Java"> lazy getter</a>. A pattern along the lines of the following.</p><pre><strong>public static </strong>List&lt;Movie&gt; getList() {<br>    <strong>if </strong>(<em>list </em>== <strong>null</strong>) {<br>        <em>list </em>= <em>createMovies</em>();<br>    }<br>    <strong>return </strong><em>list</em>;<br>}</pre><p>After the converter attempted to convert this pattern, the code would not compile since it made <em>list</em> immutable, yet the return type of <em>createMovies() </em>was mutable<em>.</em> The compiler would not allow a mutable object to be returned when the method signature was expecting an immutable object.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ldLnjUJavNTDBOI7." /></figure><p>It is a very powerful pattern to delegate loading an object, so Kotlin includes a function, <a href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy">lazy</a>, to facilitate lazy loading. By using the <em>lazy</em> function, the code now compiles.</p><pre><strong>val list</strong>: List&lt;Movie&gt; <strong>by </strong><em>lazy </em><strong>{<br>    </strong><em>createMovies</em>()<br><strong>}</strong></pre><p>Since the last line is the returned object, we now can easily create an object that is lazy-loaded with less boilerplate code!</p><p><strong>Death and Destruction</strong></p><p>If you are familiar with destructing an array or object in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">javascript</a>, then the <a href="https://kotlinlang.org/docs/reference/multi-declarations.html">destructuring declarations</a> will feel very familiar.</p><p>In Java, we use objects and pass them around all the time. However, sometimes we only need a few properties of an object but do not take the time to extract only those properties into variables.</p><p>For a large number of properties, it is easier to just access the properties from the getter. For example:</p><pre><strong>final </strong>Movie movie = (Movie) getActivity()<br>        .getIntent().getSerializableExtra(DetailsActivity.<strong><em>MOVIE</em></strong>);<br><br>// Access properties from getters<br>mMediaPlayerGlue.setTitle(movie.getTitle());<br>mMediaPlayerGlue.setArtist(movie.getDescription());<br>mMediaPlayerGlue.setVideoUrl(movie.getVideoUrl());</pre><p>However, Kotlin provides a powerful destructor declaration that simplifies accessing the properties of an object by shortening the boilerplate code of assigning each property to its own variable.</p><pre><strong>val </strong>(_, title, description, _, _, videoUrl) = <em>activity<br>        </em>.<em>intent</em>.getSerializableExtra(DetailsActivity.<strong>MOVIE</strong>) <strong>as </strong>Movie<br><br>// Access properties via variables<strong><br>mMediaPlayerGlue</strong>.setTitle(title)<br><strong>mMediaPlayerGlue</strong>.setArtist(description)<br><strong>mMediaPlayerGlue</strong>.setVideoUrl(videoUrl)</pre><p>And no surprise, the decompiled code is to be expected, where the <em>componentX()</em> methods reference our getters in our data class.</p><pre>Serializable var10000 = <strong>this</strong>.getActivity().getIntent().getSerializableExtra(<strong>&quot;Movie&quot;</strong>);<br>Movie var5 = (Movie)var10000;<br>String title = var5.component2();<br>String description = var5.component3();<br>String videoUrl = var5.component6();</pre><p>The converter was clever enough to simplify the code by destructuring the model object. However, I recommend reading about <a href="https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-in-lambdas-since-11">lambdas with destruction</a>. In Java 8, it is common to put parameters to a lambda function in parenthesis for more than one parameter. In Kotlin, <strong>that could be interpreted as a destructor.</strong></p><p><strong>Conclusion</strong></p><p>Using the conversion tool in Android Studio was a great starting point in my journey to learning Kotlin. However, seeing the some of the code that was produced has forced me to dig deeper into Kotlin to find better ways to write code.</p><p>I am glad I was warned to proofread after the conversion. Otherwise, I would have created some Kotlin code that wasn‚Äôt easy to understand! Then again, my Java code is not much better. üòä</p><p>If you want to learn more about getting started with Kotlin, check out <a href="https://developer.android.com/kotlin/get-started.html">this blog post</a>, and watch:</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FczKo-jPVweg%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DczKo-jPVweg&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FczKo-jPVweg%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/ffa26768426663b538d833752249ec2f/href">https://medium.com/media/ffa26768426663b538d833752249ec2f/href</a></iframe><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f0a3cb41669" width="1" height="1"><hr><p><a href="https://medium.com/google-developers/lessons-learned-while-converting-to-kotlin-with-android-studio-f0a3cb41669">Lessons learned while converting to Kotlin with Android Studio</a> was originally published in <a href="https://medium.com/google-developers">Google Developers</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>